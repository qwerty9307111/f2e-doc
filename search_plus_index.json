{"./":{"url":"./","title":"Introduction","keywords":"","body":"简介 Copyright © TeamSecret 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-05-11 22:01:02 "},"basic/dataType/":{"url":"basic/dataType/","title":"数据类型","keywords":"","body":"数据类型 原始类型 对象类型 类型判断 类型转换 Copyright © TeamSecret 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-05-18 09:49:48 "},"basic/dataType/primitive.html":{"url":"basic/dataType/primitive.html","title":"原始（Primitive）类型","keywords":"","body":"原始（Primitive）类型 JS 中原始类型类型有哪几种？null 是对象吗？ JS 中原始类型有哪几种？ null undefined number string boolean symbol 在最新的 ECMA proposal 里有个处于 Stage 4 的原始数据类型 BigInt ，用于表示比 253 大的所有数字。 原始类型都是不可变的（值本身无法被改变） 值存在栈（stack）中 原始类型存储的都是值，是没有函数可以调用的，比如 undefined.toString() 为什么 '1'.toString() 可以运行成功？ 因为在这种情况下，'1' 已经被强制转换为 String 类型（String{\"1\"}），所以可以调用对象原型链上的方法。 null 是对象吗？ 在 ECMA 文档里的定义是：原始值，表示缺省任何对象值（object value） 为什么 typeof null === 'object'？ typeof null === 'object' 是个早在第一版的 JS 就存在的 BUG。在这个版本里，JS 值是以 32位 为单位存储的，由1 - 3位类型标签（type tag） 和真实值组成。类型标签存储在低位的单元里。其中5个是： 000：对象（object） 1：整型（int） 010：双精度浮点型（double） 100：字符串（string） 110：布尔值（boolean） 两种特殊值 undefined：JSVAL_VOID - #define JSVAL_VOID INT_TO_JSVAL(0 - JSVAL_INT_POW2(30)) null：JSVAL_NULL - 机器码 NULL 空指针（000），而对象类型的类型标签也是 000，所以有 typeof null === 'object'。 Copyright © TeamSecret 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-05-11 23:23:15 "},"basic/dataType/object.html":{"url":"basic/dataType/object.html","title":"对象（Object）类型","keywords":"","body":"对象（Object）类型 对象类型和原始类型的不同之处？ 原始类型的值是不可更改的，而对象的值是可以修改的 let a = 1; a = 2; // 修改的是变量 a，而不是数字 1 本身 const obj = { x: 1 }; // 修改对象 obj.x = 2; obj.y = 3; const arr = [1, 2, 3]; // 修改数组 arr[0] = 0; arr[3] = 3; 原始类型存储（赋值）的是值，对象类型存储（赋值）的是地址（指针） 对于常量 a 来说，假设内存地址（指针）为 #001，那么在地址 #001 的位置存放了值 []，常量 a 存放了地址（指针） #001。 const a = []; 当我们将一个引用类型的变量赋值给另外一个变量时，复制的是原本变量的地址（指针）。也就是说当前变量 b 存放的地址（指针）也是 #001，当我们进行数据修改的时候，就会修改存放在地址（指针） #001 上的值，也就导致了两个变量的值都发生了改变。 const a = []; const b = a; b.push(1); console.log(a) // [1] 原始类型的比较是值的比较，对象的比较是引用的比较 原始类型的比较是值的比较，只有在它们的值相等时它们才相等 我们通常将对象称为引用类型（reference type），对象值都是引用（reference），对象的比较是引用的比较：只有当它们引用同一个基对象时，它们才相等。 const a = 1; const b = 1; console.log(a === b); // true 因为 1 = 1 const c = { x: 1 }; // 指针 #001 const d = { x: 1 }; // 指针 #002 console.log(c === d); // false 因为 #001 != #002 Copyright © TeamSecret 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-05-17 15:13:46 "},"basic/dataType/typeof.html":{"url":"basic/dataType/typeof.html","title":"类型判断","keywords":"","body":"类型判断 typeof typeof 是否能正确判断类型？ 对于原始类型，除了 null 都能正确返回类型。 typeof 1 // 'number' typeof '1' // 'string' typeof undefined // 'undefined' typeof true // 'boolean' typeof Symbol() // 'symbol' typeof null // 'object' 对于引用类型，除了函数对象能正确返回 function，其它都会返回 object。 typeof [] // 'object' typeof {} // 'object' typeof new Date() // 'object' typeof /RegExp/ // 'object' typeof console.log // 'function' 既然函数也是对象（可调用对象），为什么 typeof 能正确返回函数的类型？ 函数的 type tag 和普通对象以及 null 一样，也是 000。但是函数作为 JS 的一等公民，也被视为一种变量类型。typeof 内部判断如果一个对象实现了 [[call]] 内部方法则认为是函数。 Object.prototype.toString Object.prototype.toString 能区分哪些数据类型？ Object.prototype.toString 不能区分基本类型，只是用于区分各种对象（如果实参是个基本类型，会自动转成对应的引用类型）。 null 和 undefined 不存在对应的引用类型也能返回正确的结果，是因为内部做了特殊处理。 // 当判断的是基础类型时，会先做类型转换 console.log(Object.prototype.toString.call(1)); // [object Number]，隐式类型转换 console.log(Object.prototype.toString.call('')); // [object String]，隐式类型转换 console.log(Object.prototype.toString.call(true)); // [object Boolean]，隐式类型转换 // 不存在 Null 和 Undefined 引用类型，但是 Object.prototype.toString 能正确返回结果 console.log(Object.prototype.toString.call(null)); // [object Null]，特殊处理 console.log(Object.prototype.toString.call(undefined)); // [object Undefined]，特殊处理 console.log(Object.prototype.toString.call( {})); // [object Object] console.log(Object.prototype.toString.call([])); // [object Array] console.log(Object.prototype.toString.call(function(){})); // [object Function] console.log(Object.prototype.toString.call(/\\d/)); // [object RegExp] console.log(Object.prototype.toString.call(new Date())); // [object Date] Object.prototype.toString 判断数据类型的原理是什么？ Symbol.toStringTag 属性 Symbol.toStringTag 是一个内置 symbol，它用来表示该对象的自定义类型标签，只能通过 Object.prototype.toString 访问。 const str = '1'; console.log(Object.prototype.toString.call(str)); // [object String] Object.defineProperty(String.prototype, Symbol.toStringTag, { get () { return '自定义类型'; } }); console.log(Object.prototype.toString.call(str)); // [object 自定义类型] 在上面的例子中，我们通过修改 String.prototype 的 Symbol.toStringTag 属性，使 Object.prototype.toString 返回了一个自定义类型，这也意味着 Object.prototype.toString 的结果并不总是可靠的。 内部属性 [[Class]] 每个对象都有个内部属性 [[Class]]，其属性值是一个字符串，表示规范定义的对象分类（A String value indicating a specification defined classification of objects.）。只能通过 Object.prototype.toString 访问。 Object.prototype.toString 判断逻辑 如果实参是 undefined, 则返回 \"[object Undefined]\"； 如果实参是 null, 则返回 \"[object Null]\"； 把基础类型的实参转换成对象类型； 获取对象的 Symbol.toStringTag 属性值 subType 如果 subType 是个字符串，则返回 [object subType] 否则获取对象的 [[Class]] 属性值 type，并返回 [object type] class Person { constructor (name, age) { this.name = name; this.age = age; } } // 找不到 Symbol.toStringTag 属性时，返回默认的 [[Class]] 属性值（Object） const p1 = new Person('张三', 18) console.log(Object.prototype.toString.call(p1)); // [object Object] // 定义 Person 类的 Symbol.toStringTag 属性 Object.defineProperty(Person.prototype, Symbol.toStringTag, { get () { // 如果这里 return 的不是一个字符串，那么 Object.prototype.toString 将返回默认的 [[Class]] 属性值 // return true; // 下面的 p2 将返回 [object Object] return 'Person'; } }); const p2 = new Person('李四', 18) console.log(Object.prototype.toString.call(p2)); // [object Person] instanceof a instanceof b instanceof 操作符通过检查构造函数 b 的 prototype 属性是否在对象 a 的原型链上，来判断对象的类型。 instanceof 会对要检查的值进行类型转换吗？ instanceof 操作符不会对变量 a 进行隐式类型转换。 \"\" instanceof String; // false，基本类型不会转成对象 Object('') instanceof String; // true 一个对象类型的变量调用 instanceof Object 有可能会返回 false 吗？ 由于 instanceof 是通过原型链来判断的，对于没有原型的对象将直接返回 false。 const obj = Object.create(null); console.log(typeof obj); // object console.log(Object.prototype.toString.call(obj)); // [object Object] console.log(obj instanceof Object); // false 因为 obj 对象没有原型 instanceof 右侧可以是任意值吗？ instanceof 右侧必须是个对象，并且大部分情况要求是个构造函数（即要具有 prototype 属性）。 // TypeError: Right-hand side of 'instanceof' is not an object 1 instanceof 1; // TypeError: Right-hand side of 'instanceof' is not callable 1 instanceof ({}); // TypeError: Function has non-object prototype 'undefined' in instanceof check ({}) instanceof (() => {}); intanceof 有什么缺陷？ 不同的全局执行上下文的对象和函数都是不相等的，所以对于跨全局执行上下文， intanceof 就不能正常工作了。 const iframe = window.frames[0]; const iframeArr = new iframe.Array(); console.log([] instanceof iframe.Array); // false console.log(iframeArr instanceof Array); // false console.log(iframeArr instanceof iframe.Array); // true 为什么 instanceof 也不是百分之百可信的？ instanceof 操作符判断构造函数的 prototype 属性是否在对象的原型链上。但是可以利用 Symbol.hasInstance 自定义 instanceof 操作逻辑。 Object.defineProperty(Object, Symbol.hasInstance, { value (v) { return typeof v === 'string'; } }); console.log(({}) instanceof Object); // false console.log('' instanceof Object); // true instanceof 判断逻辑 object instanceof constructorFunc 如果 object 不是对象，或者 constructorFunc 不是构造函数，直接抛 TypeError 异常； 如果有 constructorFunc[Symbole.hasInstance] 方法，则返回 !!constructorFunc[Symbole.hasInstance](object) 遍历 object 的原型链，逐个跟 constructorFunc.prototype 属性比较： 如果 object 没有原型，则直接返回 false; 如果 constructorFunc.prototype 不是对象，则直接抛 TypeError 异常。 自己实现一个 instanceof function myInstanceof (left, right) { // 首先获取类型的原型 let prototype = right.prototype // 然后获得对象的原型 left = left.__proto__ // 一直循环判断对象的原型是否等于类型的原型，直到对象原型为 null，因为原型链最终为 null while (true) { if (left === null || left === undefined) { return false } if (prototype === left) { return true } left = left.__proto__ } } Copyright © TeamSecret 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-09-22 17:18:29 "},"basic/dataType/exchange.html":{"url":"basic/dataType/exchange.html","title":"类型转换","keywords":"","body":"类型转换 JS 中如何进行类型转换？ 值1 转换为： 字符串 1数值 1布尔值 1对象 undefined \"undefined\" NaN false throws TypeError null \"null\" 0 false throws TypeError true \"true\" 1 new Boolean(true) false \"false\" 0 new Boolean(false) \"\"（\"空字符串\"） 0 false new String(\"\") \"1.2\"（非空，数字） 1.2 true new String(\"1.2\") \"one\"（非空，非数字） NaN true new String(\"one\") 0 \"0\" false new Number(0) -0 \"0\" false new Number(-0) NaN \"NaN\" false new Number(NaN) Infinity \"Infinity\" true new Number(Infinity) -Infinity \"-Infinity\" true new Number(-Infinity) 1（非零） \"1\" true new Number(1) {}（任意对象） 参考对象转原始类型 参考对象转原始类型 true []（空数组） \"\" 0 true [1]（1 个数字元素） \"1\" 1 true ['a', 'b']（其它数组） \"a,b\" NaN true function(){}（任意函数） 参考对象转原始类型 NaN true 对象转换为原始类型 对象到布尔值的转换非常简单：所有对象都转换为 true。对于包装对象也是如此：new Boolean(false) 将转换为 true。 对象转字符串（object-to-string）和对象转数字（object-to-number）是通过调用待转换对象的一个方法来完成的。麻烦的是，js 中有 3 个不同的方法来执行转换： [Symbol.toPrimitive] toString valueOf 转换逻辑如下： 对象是否重写了 [Symbol.toPrimitive]方法？ 如果对象重写了 [Symbol.toPrimitive]，且该方法返回一个原始类型，则返回转换的值 如果对象重写了 [Symbol.toPrimitive]，且该方法返回的不是一个原始类型，则抛出一个类型错误异常 转换为字符串 如果对象具有toString()方法，则调用这个方法。如果它返回一个原始值，JS将这个值转换为字符串并返回。 如果对象不具有toString()方法，或者这个方法不返回一个原始值，那么JS会调用valueOf方法。如果存在这个方法，且返回值是一个原始值，JS将这个值转换为字符串并返回。 否则，JS无法从toString()方法或valueOf()方法获得一个原始值，将会抛出一个类型错误异常。 转换为数值 如果对象具有valueOf()方法，则调用这个方法。如果它返回一个原始值，JS将这个值转换为数值并返回。 如果对象不具有valueOf()方法，或者这个方法不返回一个原始值，那么JS会调用toString方法。如果存在这个方法，且返回值是一个原始值，JS将这个值转换为数值并返回。 否则，JS无法从toString()方法或valueOf()方法获得一个原始值，将会抛出一个类型错误异常。 为什么在处理数组转换为数字时，空数组被转换为 0 ？以及单元素的数组同样会转换为一个数字？ 数组继承了默认的valueOf()，这个方法返回数组本身（不是一个原始值），因此数组到数字的转换会去调用toString()方法。 [1].valueOf() // 返回数组本身 [1] [1].toString() // \"1\" 空数组转换为空字符串，再转换为数字就是 0： // 先调用 [].valueOf() 返回 []，不是原始类型 // 接着调用 [].toString() 返回空字符串 \"\" // 将字符串 \"\" 转换为数字（0）并返回 Number([]) // [] => \"\" => 0 单元素数组转换为该元素的字符串形式，再转换为数字： // [1].valueOf() => [1] // [1].toString() => \"1\" // Number(\"1\") => 1 [1] => '1' => 1 ['1'] => '1' => 1 ['1.2'] => '1.2' => 1.2 ['hello'] => 'hello' => NaN Copyright © TeamSecret 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-05-27 15:07:01 "},"basic/operator/":{"url":"basic/operator/","title":"运算符","keywords":"","body":"运算符 Copyright © TeamSecret 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-05-27 17:27:38 "},"basic/operator/+.html":{"url":"basic/operator/+.html","title":"“+”运算符","keywords":"","body":"“+” 运算符 一元加操作符 一元加操作符放在数值前面，对数值不会产生任何影响。 在对非数值使用一元操作符时，会将这个值转换为 Number 类型（一元加操作符是将值转换为 Number 类型最快的方法，因为它不会对数字执行任何其他操作）。 let num = 1 let s1 = '01' let s2 = '1.1' let s3 = 'string' let b = false let obj = { valueOf () { return -1 } } num = +num // 仍然是 1 s1 = +s1 // 转换为数值 1 s2 = +s2 // 转换为数值 1.1 s3 = +s3 // 转换为 NaN b = +b // 转换为数值 0 obj = +obj // 转换为数值 -1 二元加法运算符 二元加法运算符 “+” 可以对两个数字做加法，也可以做字符串连接操作。 计算规则： 如果两个计算值都是数值： 如果有一个操作数是 NaN，则返回 NaN； 如果是 Infinity 加 Infinity，则返回 Infinity； 如果是 -Infinity 加 -Infinity，则返回 -Infinity； 如果是 Infinity 加 -Infinity，则返回 NaN； 如果是 +0 加 +0，则返回 +0； 如果是 -0 加 -0，则返回 -0； 如果是 +0 加 -0，则返回 +0； 如果有一个计算值是字符串： 如果两个计算值都是字符串，则拼接字符串； 如果只有一个字符串，则将另一个计算值转换为字符串，再进行拼接； 1 + 2 // 3 \"1\" + \"2\" // \"12\" Copyright © TeamSecret 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-08-26 14:46:52 "},"basic/operator/relational.html":{"url":"basic/operator/relational.html","title":"比较运算符","keywords":"","body":"比较运算符 小于（）、小于等于（=） 如果两个操作数都是数值，则执行数值比较； 如果两个操作数都是字符串，则比较】字符串对应的字符编码值； 如果一个操作数是数值，则将另一个转换为数值，再进行数值比较； 如果一个操作数是布尔值，则将其转换为数值，再进行比较； 如果一个操作数是对象，则取其 valueOf 方法的返回值，按前面的规则比较。如果没有 valueOf 方法，则取其 toString 方法的返回值进行比较。 let a = { valueOf() { return 0 }, toString() { return '1' } } a > -1 // true Copyright © TeamSecret 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-08-26 14:45:39 "},"basic/operator/==.html":{"url":"basic/operator/==.html","title":"“==”运算符","keywords":"","body":"相等操作符 == 和 === 有什么区别？ 对于 == 来说，如果对比双方的类型不一样的话，就会进行类型转换，转换规则： 首先会判断两者类型是否相同。相同的话就是比大小了 类型不相同的话，那么就会进行类型转换 会先判断是否在对比 null 和 undefined，是的话就会返回 true 判断两者类型是否为 string 和 number，是的话就会将字符串转换为 number 1 == '1' ↓ 1 == 1 判断其中一方是否为 boolean，是的话就会把 boolean 转为 number 再进行判断 '1' == true ↓ '1' == 1 ↓ 1 == 1 判断其中一方是否为 object 且另一方为 string、number 或者 symbol，是的话就会把 object 转为原始类型再进行判断 '1' == { } ↓ '1' == '[object Object]' [] == ![] 为什么返回 true? [] == ![] ↓ 0 == false ↓ 0 == 0 Copyright © TeamSecret 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-08-31 10:45:27 "},"basic/operator/new.html":{"url":"basic/operator/new.html","title":"new 运算符","keywords":"","body":"new 运算符 new 的原理是什么？ 在调用 new 的过程中会发生以上四件事情： 新生成一个对象 链接到原型 绑定 this 返回新对象 手写 new 操作符 function create () { // 创建一个空对象 const obj = {} // 获取构造函数 const Con = [].shift.call(arguments) // 设置空对象的原型 obj.__proto__ = Con.prototype // 绑定 this 并执行构造函数 const result = Con.apply(obj, arguments) // 确保返回一个对象 return result instanceof Object ? result : obj } 通过 new 的方式创建对象和通过字面量创建有什么区别？ 对于对象来说，其实都是通过 new 产生的，无论是 function Foo() 还是 let a = { b : 1 } 。 对于创建一个对象来说，更推荐使用字面量的方式创建对象（无论性能上还是可读性）。因为你使用 new Object() 的方式创建对象需要通过作用域链一层层找到 Object，但是你使用字面量的方式就没这个问题。 // function 就是个语法糖 // 内部等同于 new Function() function Foo() {} // 这个字面量内部也是使用了 new Object() let a = { b: 1 } Copyright © TeamSecret 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-09-22 20:33:27 "},"basic/this/this.html":{"url":"basic/this/this.html","title":"this","keywords":"","body":"this 如何正确判断 this？箭头函数的 this 是什么？ function foo() { console.log(this.a) } var a = 1 foo() const obj = { a: 2, foo: foo } obj.foo() const c = new foo() 对于直接调用 foo 来说，不管 foo 函数被放在了什么地方，this 一定是 window 对于 obj.foo() 来说，我们只需要记住，谁调用了函数，谁就是 this，所以在这个场景下 foo 函数中的 this 就是 obj 对象 对于 new 的方式来说，this 被永远绑定在了 c 上面，不会被任何方式改变 this 箭头函数中的 this 只取决包裹箭头函数的第一个普通函数的 this。 最后种情况也就是 bind 这些改变上下文的 API 了，对于这些函数来说，this 取决于第一个参数，如果第一个参数为空，那么就是 window。 如果多种规则同时出现，这时候不同的规则之间会根据优先级最高的来决定 this 最终指向哪里。 首先，new 的方式优先级最高，接下来是 bind 这些函数，然后是 obj.foo() 这种调用方式，最后是 foo 这种调用方式，同时，箭头函数的 this 一旦被绑定，就不会再被任何方式所改变。 Copyright © TeamSecret 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-09-08 16:00:50 "},"basic/callApplyBind/":{"url":"basic/callApplyBind/","title":"call、apply 及 bind","keywords":"","body":"call、apply 和 bind call、apply 和 bind 有什么区别？ 首先，三者都可以改变函数的 this 指向。 三者第一个参数都是 this 要指向的对象，如果如果没有这个参数或参数为 undefined 或 null，则默认指向全局 window。 三者都可以传参，但是 apply 是数组，而 call 和 bind 是参数列表，且 apply 和 call 是一次性传入参数，而 bind 可以分为多次传入。 bind 是返回绑定 this 之后的函数，便于稍后调用；apply 、call 则是立即执行。 bind()会返回一个新的函数，如果这个返回的新的函数作为构造函数创建一个新的对象，那么此时 this 不再指向传入给 bind 的第一个参数，而是指向用 new 创建的实例。 手写 call、apply 及 bind 函数 手写 call 关键点在于： 不传入第一个参数，那么上下文默认为 window 改变了 this 指向，让新的对象可以执行该函数，并能接受参数 Function.prototype.myCall = function (context) { // myCall 的调用方式为 xxx.myCall(obj, ...) // 谁调用了 myall，这里的 this 就指向谁 // 因此，首先保证调用 myCall 的是一个函数 if (typeof this !== 'function') { throw new TypeError('Error') } // 当 myCall 的第一个参数为 undefined 或 null 时，默认指向全局 window context = (context === undefined || context === null) ? window : context // 将 this 函数绑定到 context 上 context.fn = this // 获取除 context 外的其它入参 const args = [...arguments].slice(1) // 运行函数 const result = context.fn(...args) delete context.fn return result } 手写 apply apply 和 call 的区别就在于传参的不同，apply 接收的是一个数组 Function.prototype.myApply = function (context) { if (typeof this !== 'function') { throw new TypeError('Error') } context = context || window context.fn = this const args = arguments[1] let result = null if (args) { result = context.fn(...args) } else { result = context.fn() } delete context.fn return result } 手写 bind Function.prototype.MyBind = function (context) { // 首先保证调用 MyBind 的是一个函数 if (typeof this !== 'function') { throw new TypeError('Error') } // 当 MyBind 的第一个参数为 undefined 或 null 时，默认指向全局 window context = (context === undefined || context === null) ? window : context const that = this // 获取除 context 外的其它入参 const args = [...arguments].slice(1) // bind 返回了一个函数，对于函数来说有两种方式调用，一种是直接调用，一种是通过 new 的方式 return function F () { if (this instanceof F) { // 当通过 new 的方式调用时,this 不会被任何方式改变，所以对于这种情况我们需要忽略传入的 this return new that(...args, ...arguments) } // 对于直接调用来说，这里选择了 apply 的方式实现 // 但是对于参数需要注意以下情况：因为 bind 可以实现类似这样的代码 f.bind(obj, 1)(2) // 所以我们需要将两边的参数拼接起来，于是就有了这样的实现 args.concat(...arguments) return that.apply(context, args.concat(...arguments)) } } Copyright © TeamSecret 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-09-22 17:01:50 "},"basic/闭包/":{"url":"basic/闭包/","title":"闭包","keywords":"","body":"闭包 什么是闭包？ 闭包的定义其实很简单：函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包。 function A() { let a = 1 window.B = function () { console.log(a) } } A() B() // 1 举出闭包实际场景运用的例子 常见的防抖节流 // 防抖 function debounce (fn, delay = 300) { let timer; // 闭包引用的外界变量 return function () { const args = arguments; if (timer) { clearTimeout(timer) } timer = setTimeout(() => { fn.apply(this, args); }, delay); } } // 节流 function throttle (fn, delay = 300) { let timer; return function () { const args = arguments; if (timer) { return; } timer = setTimeout(() => { fn.apply(this, args); timer = null; }, delay) } } 使用闭包可以在 JavaScript 中模拟块级作用域。 function outputNumbers(count) { (function () { for (var i = 0; i 闭包可以用于在对象中创建私有变量 var aaa = (function () { var a = 1; function bbb() { a++; console.log(a); } function ccc() { a++; console.log(a); } return { b: bbb, c: ccc, }; })(); console.log(aaa.a); //undefined aaa.b(); //2 aaa.c(); //3 Copyright © TeamSecret 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-09-07 10:36:29 "},"basic/copy/":{"url":"basic/copy/","title":"深浅拷贝","keywords":"","body":"深浅拷贝 什么是浅拷贝？如何实现浅拷贝？什么是深拷贝？如何实现深拷贝？ 浅拷贝和深拷贝有什么区别？ 浅拷贝是创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。 深拷贝是将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象。 如何实现浅拷贝？ 直接赋值 const a = { name: '张三' } const b = a a.name = '李四' console.log(b.name) // 李四 Object.assign 如果对象的属性值都是基础数据类型，则可视为深拷贝，但如果属性值中存在引用数据类型，则只是浅拷贝。 const a = { id: 1, person: { name: '张三' } } const b = Object.assign({}, a) a.id = 2 a.person.name = '李四' console.log(b.id) // 1 // a.id 的修改并不会影响 b.id 的值 console.log(b.person.name) // 李四 扩展运算符（...） 拷贝规则同 Object.assign const a = { id: 1, person: { name: '张三' } } const b = {...a} a.id = 2 a.person.name = '李四' console.log(b.id) // 1 console.log(b.person.name) // 李四 Array.prototype.concat() 拷贝规则同 Object.assign const a = [1, { name: '张三' }] const b = a.concat([]) a[0] = 0 a[1].name = '李四' console.log(b) // [1, { name: '李四' }] Array.prototype.slice() 拷贝规则同 Object.assign const a = [1, { name: '张三' }] const b = a.slice() a[0] = 0 a[1].name = '李四' console.log(b) // [1, { name: '李四' }] 如何实现深拷贝？ JSON.parse(JSON.stringify(data)) 该方法会忽略 undefined 会忽略 symbol 不能序列化函数 不能解决循环引用的对象 正则、Map、Set 等数据会序列化为一个空对象 const a = { id: 1, person: { name: '张三', age: undefined, address: Symbol('location') }, say () { console.log('say something') } } const b = JSON.parse(JSON.stringify(a)) console.log(b) // { id: 1, person: { name: '张三' } } age, address 属性以及 say 方法都会丢失 a.person.obj = a.person // 当 a 存在循环引用时，这里会报错 Uncaught TypeError: Converting circular structure to JSON const c = JSON.parse(JSON.stringify(a)) 可以使用 MessageChannel 解决 undefined 和循环引用问题 当属性值存在 symbol 和 function 时会报错 const structuralClone = obj => new Promise(resolve => { const { port1, port2 } = new MessageChannel() port1.postMessage(obj) port2.onmessage = e => resolve(e.data) }) async function cloneDeep (obj) { const copyData = await structuralClone(obj) console.log(copyData) return copyData } const a = { b: undefined, c: new Set([[1, 2]]), d: new Map([[1, 2]]), e: { f: 'f' } } a.e.g = a.e cloneDeep(a) 递归复制 const isObject = o => (typeof o === 'object' || typeof o === 'function') && o !== null const deepClone = obj => { // 如果如参不是一个引用数据类型，则直接返回 if (!isObject(obj)) { return obj } let res = Array.isArray(obj) ? [...obj] : {...obj} // 复制 // 遍历复制结果的每一个值 Object.keys(res).forEach(keyName => { // 如果属性值是一个对象，则递归调用 deepClone，否则直接赋值 res[keyName] = isObject(obj[keyName]) ? deepClone(obj[keyName]) : obj[keyName] }) return res }; Copyright © TeamSecret 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-09-08 14:48:52 "},"basic/prototype/":{"url":"basic/prototype/","title":"原型和原型链","keywords":"","body":"原型和原型链 如何理解原型？如何理解原型链？ 当我们创建一个对象时 let obj = { age: 25 }，我们可以发现能使用很多种函数，但是我们明明没有定义过它们，对于这种情况你是否有过疑惑？ 当我们在浏览器中打印 obj 时你会发现，在 obj 上居然还有一个 __proto__ 属性，那么看来之前的疑问就和这个属性有关系了。 其实每个 JS 对象都有 __proto__ 属性，这个属性指向了原型。这个属性在现在来说已经不推荐直接去使用它了，这只是浏览器在早期为了让我们访问到内部属性 [[prototype]] 来实现的一个东西。 讲到这里好像还是没有弄明白什么是原型，接下来让我们再看看 __proto__ 里面有什么吧。 看到这里你应该明白了，原型也是一个对象，并且这个对象中包含了很多函数，所以我们可以得出一个结论：对于 obj 来说，可以通过 __proto__ 找到一个原型对象，在该对象中定义了很多函数让我们来使用。 在上面的图中我们还可以发现一个 constructor 属性，也就是构造函数。 打开 constructor 属性我们又可以发现其中还有一个 prototype 属性，并且这个属性对应的值和先前我们在 __proto__ 中看到的一模一样。所以我们又可以得出一个结论：原型的 constructor 属性指向构造函数，构造函数又通过 prototype 属性指回原型，但是并不是所有函数都具有这个属性，Function.prototype.bind() 就没有这个属性。 其实原型链就是多个对象通过 __proto__ 的方式连接了起来。为什么 obj 可以访问到 valueOf 函数，就是因为 obj 通过原型链找到了 valueOf 函数。 对于这一小节的知识点，总结起来就是以下几点： Object 是所有对象的爸爸，所有对象都可以通过 __proto__ 找到它 Function 是所有函数的爸爸，所有函数都可以通过 __proto__ 找到它 函数的 prototype 是一个对象 对象的 __proto__ 属性指向原型， __proto__ 将对象和原型连接起来组成了原型链 练习 function Foo () {} var foo = new Foo(); foo.__proto__ === Foo.prototype; // true foo.__proto__.__proto__ === Object.prototype; // true foo.__proto__.__proto__.__proto__ === null; // true 解析： Copyright © TeamSecret 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-09-09 15:55:23 "},"basic/extends/":{"url":"basic/extends/","title":"继承","keywords":"","body":"继承 1.原型链继承 ECMAScript 中描述了原型链的概念，并将其作为实现继承的主要方法。其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。代码大致如下： // 定义父类 function SuperType () { this.property = true } SuperType.prototype.getSuperValue = function () { console.log(this.property) } // 定义子类 function SubType () { this.subProperty = false } // 继承 SuperType SubType.prototype = new SuperType() // 定义子类方法，一定要放在替换原型的语句之后 SubType.prototype.getSubValue = function () { console.log(this.subProperty) } // 创建实例对象 const sub = new SubType() // 检验 console.log(sub.getSuperValue()) // true console.log(sub.getSubValue()) // false console.log(sub instanceof SubType) // true console.log(sub instanceof SuperType) // true 原型链的问题 最主要的问题来自包含引用类型值的原型。 在通过原型来实现继承时，子类原型实际上会变成父类的实例。于是父类的实例属性也就顺理成章地变成了子类的原型属性了。演示代码如下： function SuperType () { this.colors = ['red', 'green', 'blue'] } function SubType () {} SubType.prototype = new SuperType() const sub_1 = new SubType() sub_1.colors.push('yellow') console.log(sub_1.colors) // ['red', 'green', 'blue', 'yellow'] const sub_2 = new SubType() console.log(sub_2.colors) // ['red', 'green', 'blue', 'yellow'] 原型链的第二个问题是：在创建子类实例时，不能向父类的构造函数中传递参数。 2.借用构造函数（也叫伪造对象或者经典继承） 借用构造函数的技术就是为了解决原型中包含引用类型值所带来的问题。其基本思想就是在子类的构造函数内部调用父类的构造函数。 function SuperType () { this.colors = ['red', 'green', 'blue'] } function SubType () { // 继承 SuperType SuperType.call(this) } const sub_1 = new SubType() sub_1.colors.push('yellow') console.log(sub_1.colors) // ['red', 'green', 'blue', 'yellow'] const sub_2 = new SubType() console.log(sub_2.colors) // ['red', 'green', 'blue'] 传递参数 相对于原型链而言，借用构造函数还可以在子类构造函数中向父类传递参数： function SuperType (name) { this.name = name } SuperType.prototype.say = function () { console.log('My name is ' + this.name) } function SubType () { // 继承 SuperType，同时传递参数 SuperType.call(this, '张三') // 实例属性 // 为了保证父类构造函数不会重写子类的属性，应当在调用父类构造函数后，再添加自定义属性 this.age = 18 } const sub = new SubType() console.log(sub.name) // 张三 console.log(sub.age) // 18 sub.say() // Uncaught TypeError: sub.say is not a function 借用构造函数的问题 方法都在构造函数中定义，因此函数复用就无从谈起了。 在父类原型中定义的方法，对子类而言是不可见的。 function SuperType (name) { this.name = name } SuperType.prototype.say = function () { console.log('My name is ' + this.name) } function SubType () { // 继承 SuperType，同时传递参数 SuperType.call(this, '张三') } const sub = new SubType() sub.say() // Uncaught TypeError: sub.say is not a function 3. 组合继承（伪经典继承） 组合继承是最常用的继承方式，指的是将原型链和借用构造函数的技术组合到一起的继承模式，思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数实现对实例属性的继承。 function SuperType (name) { this.name = name this.colors = ['red', 'green', 'blue'] } SuperType.prototype.say = function () { console.log('My name is ' + this.name) } function SubType (name, age) { // 继承属性 SuperType.call(this, name) this.age = age } // 继承方法 SubType.prototype = new SuperType() SubType.prototype.sayAge = function () { console.log(this.age) } const sub_1 = new SubType('张三', 18) sub_1.colors.push('yellow') console.log(sub_1.colors) // [\"red\", \"green\", \"blue\", \"yellow\"] sub_1.say() // My name is 张三 sub_1.sayAge() // 18 const sub_2 = new SubType('李四', 20) console.log(sub_2.colors) // [\"red\", \"green\", \"blue\"] sub_2.say() // My name is 李四 sub_2.sayAge() // 20 这种继承方式优点在于构造函数可以传参，不会与父类引用属性共享，可以复用父类的函数，但是也存在一个缺点就是在继承父类函数的时候调用了父类构造函数，导致子类的原型上多了不需要的父类属性，存在内存上的浪费。 寄生组合式继承 所谓寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。其背后的基本思路是：不必为了指定子类的原型而调用父类的构造函数，我们所需要的无非是父类原型的一个副本而已。 function SuperType (name) { this.name = name this.colors = ['red', 'green', 'blue'] } SuperType.prototype.sayName = function () { console.log(this.name) } function SubType (name, age) { // 继承属性 SuperType.call(this, name) this.age = age } // 继承方法 // 创建父类原型的副本，并将构造函数指向子类 SubType.prototype = Object.create(SuperType.prototype, { constructor: { value: SubType } }) SubType.prototype.sayAge = function () { console.log(this.age) } const sub_1 = new SubType('张三', 18) sub_1.colors.push('yellow') console.log(sub_1.colors) // [\"red\", \"green\", \"blue\", \"yellow\"] sub_1.sayName() // 张三 sub_1.sayAge() // 18 const sub_2 = new SubType('李四', 20) console.log(sub_2.colors) // [\"red\", \"green\", \"blue\"] sub_2.sayName() // 李四 sub_2.sayAge() // 20 class 继承 class 实现继承的核心在于使用 extends 表明继承自哪个父类，并且在子类构造函数中必须调用 super，因为这段代码可以看成 Parent.call(this, value)。 class SuperType { constructor(name) { this.name = name this.colors = [\"red\", \"green\", \"blue\"] } sayName() { console.log(this.name) } } class SubType extends SuperType { constructor(name, age) { super(name) this.age = age } sayAge () { console.log(this.age) } } const sub_1 = new SubType('张三', 18) sub_1.colors.push('yellow') console.log(sub_1.colors) // [\"red\", \"green\", \"blue\", \"yellow\"] sub_1.sayName() // 张三 sub_1.sayAge() // 18 const sub_2 = new SubType('李四', 20) console.log(sub_2.colors) // [\"red\", \"green\", \"blue\"] sub_2.sayName() // 李四 sub_2.sayAge() // 20 Copyright © TeamSecret 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-09-10 16:23:12 "},"basic/modules/":{"url":"basic/modules/","title":"模块化","keywords":"","body":"模块化 为什么要使用模块化？都有哪几种方式可以实现模块化，各有什么特点？ 使用模块化可以给我们带来以下好处 解决命名冲突 提供复用性 提高代码可维护性 立即执行函数 在早期，使用立即执行函数实现模块化是常见的手段，通过函数作用域解决了命名冲突、污染全局作用域的问题。 (function(globalVariable){ globalVariable.test = function() {} // ... 声明各种变量、函数都不会污染全局作用域 })(globalVariable) AMD 和 CMD // AMD define(['./a', './b'], function(a, b) { // 加载模块完毕可以使用 a.do() b.do() }) // CMD define(function(require, exports, module) { // 加载模块 // 可以把 require 写在函数体的任意地方实现延迟加载 var a = require('./a') a.doSomething() }) CommonJS 和 ES Module CommonJS 是一种模块规范，最初被应用于 Nodejs，成为 Nodejs 的模块规范。运行在浏览器端的 JavaScript 由于也缺少类似的规范，在 ES6 出来之前，前端也实现了一套相同的模块规范 (例如: AMD)，用来对前端模块进行管理。自 ES6 起，引入了一套新的 ES6 Module 规范，在语言标准的层面上实现了模块功能，而且实现得相当简单，有望成为浏览器和服务器通用的模块解决方案。但目前浏览器对 ES6 Module 兼容还不太好，我们平时在 Webpack 中使用的 export 和 import，会经过 Babel 转换为 CommonJS 规范。在使用上的差别主要有： CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。 CommonJS 模块是运行时加载，ES6 模块是编译时输出接口（静态编译）。 CommonJs 是单个值导出，ES6 Module 可以导出多个。 CommonJs 是动态语法可以写在判断里，ES6 Module 静态语法只能写在顶层。 CommonJs 的 this 是当前模块，ES6 Module 的 this 是 undefined。 Copyright © TeamSecret 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-09-13 10:06:05 "},"basic/Proxy/":{"url":"basic/Proxy/","title":"Proxy","keywords":"","body":"Proxy 和 Reflect Proxy Vue3.0 中通过 Proxy 替换原本的 Object.defineProperty 来实现数据响应式。 Proxy 是 ES6 中新增的功能，它可以用来自定义对象中的操作。 基本语法 target 代表需要添加代理的对象，handler 用来自定义对象中的操作，比如可以用来自定义 set 或者 get 函数。 let p = new Proxy(target, handler) Proxy 相对于 Object.defineProperty 的优势 Proxy 可以直接监听对象而非属性； Proxy 可以直接监听数组的变化； Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的； Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改； Object.defineProperty 的优势在于其兼容性更好，支持 IE 9。Proxy 是无法通过 polyfill 兼容的，因此在 Vue 3.0 中才开始使用。 使用 Proxy 实现一个数据响应式 const handleWatch = (obj, handleSet, handleGet) => { const handler = { get (target, property, receiver) { handleGet(target, property) if (typeof target[property] === 'object' && target[property] !== null) { return new Proxy(target[property], handler); } else { return Reflect.get(target, property); } }, set (target, property, value, receiver) { handleSet(value, property) return Reflect.set(target, property, value, receiver) } } return new Proxy(obj, handler) } const obj = { a: 1 } const p = handleWatch({ a: 12 }, (v, k) => { console.log('set', v, k) }, (v, k) => { console.log('get', v, k) }) p.a p.a = 22 Reflect Reflect 对象和 Proxy 对象一样，也是 ES6 为了操作对象提供的新 api。 Reflect 对象的设计目的有这样几个： 将 Object 对象的一些明显的属于语音内部的方法（比如 Object.defineProperty）,放到 Reflect 对象上。现阶段，某些方法同时在 Object 和 Reflect 对象上部署，未来的新方法只部署在 Reflect 对象上，也就是说从 Reflect 上可以拿到语言内部的方法。 修改某些 Object 方法的返回结果，让其变的合理。比如 Object.defineProperty(obj, name, desc) 在无法定义属性时，会抛出一个错误，而 Reflect.defineProperty(obj, name, desc) 则会返回 false。 让 Object 操作都变成函数行为。某些 Object 操作是命令式，比如 name in obj 和 delete obj[name],而 Reflect.has(obj, name) 和 Reflect.deleteProperty(obj, name) 让它们变成了函数行为。 Reflect 对象的方法与 Proxy 对象的方法一一对应，只要是 Proxy 对象的方法，就能在 Reflect 对象上找到对应的方法。这就让 Proxy 对象可以方便的调用对应的 Reflect 方法，完成默认行为，作为修改行为的基础。 Copyright © TeamSecret 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-10-20 10:50:13 "},"basic/sync/":{"url":"basic/sync/","title":"异步","keywords":"","body":"JS 异步编程 并发（concurrency）和并行（parallelism）区别 并发是宏观概念，我分别有任务 A 和任务 B，在一段时间内通过任务间的切换完成了这两个任务，这种情况就可以称之为并发。 并行是微观概念，假设 CPU 中存在两个核心，那么我就可以同时完成任务 A、B。同时完成多个任务的情况就可以称之为并行。 回调函数的概念 JS 语言对异步编程的实现，就是回调函数。所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。 比如 Node 中的读取文件： fs.readFile('/etc/passwd', function (err, data) { if (err) throw err; console.log(data); }); 在存在多个回调函数嵌套时，比如读取A文件之后，再读取B文件: fs.readFile(fileA, function (err, data) { fs.readFile(fileB, function (err, data) { // ... }); }); 如果依次读取多个文件，就会出现多重嵌套。这种情况就称为“回调地狱”。 回调函数还有其它的问题，比如：不能使用 try catch 捕获错误；不能直接 return。 Promise 为了解决“回调地狱”的问题，提出了 Promise 这种新的写法。Promise 有三种状态，分别是： 等待（pending） 完成 （resolved） 拒绝（rejected） Promise 一旦从等待状态变成为其他状态就永远不能更改状态了，也就是说一旦状态变为 resolved 后，就不能再次改变: new Promise((resolve, reject) => { resolve('success') // 无效 reject('reject') }) Promise 实现了链式调用，也就是说每次调用 then 之后返回的都是一个 Promise，并且是一个全新的 Promise，原因也是因为状态不可变。如果你在 then 中使用了 return，那么 return 的值会被 Promise.resolve() 包装。 Promise.resolve(1) .then(res => { console.log(res) // => 1 return 2 // 包装成 Promise.resolve(2) }) .then(res => { console.log(res) // => 2 }) Promise 的最大问题是代码冗余，原来的任务被 Promise 包装了一下，不管什么操作，一眼看去都是一堆 then，原来的语义变得很不清楚。 Generator Generator 函数是协程在 ES6 的实现，最大特点就是可以交出函数的执行权（即暂停执行）。 function *foo (x) { let y = 2 * (yield (x + 1)) let z = yield (y / 3) return (x + y + z) } let it = foo(5) console.log(it.next()) // => {value: 6, done: false} console.log(it.next(12)) // => {value: 8, done: false} console.log(it.next(13)) // => {value: 42, done: true} 首先 Generator 函数调用和普通函数不同，它会返回一个迭代器 当执行第一次 next 时，传参会被忽略，并且函数暂停在 yield (x + 1) 处，所以返回 5 + 1 = 6 当执行第二次 next 时，传入的参数等于上一个 yield 的返回值，如果你不传参，yield 永远返回 undefined。此时 let y = 2 * 12，所以第二个 yield 等于 2 * 12 / 3 = 8 当执行第三次 next 时，传入的参数会传递给 z，所以 z = 13, x = 5, y = 24，相加等于 42 async / await 一个函数如果加上 async，那么该函数就会返回一个 Promise: async function test() { return \"1\" } console.log(test()) // -> Promise {: \"1\"} async 就是将函数返回值使用 Promise.resolve() 包裹了下，和 then 中处理返回值一样，并且 await 只能配套 async 使用。 async 和 await 可以说是异步终极解决方案了，相比直接使用 Promise 来说，优势在于处理 then 的调用链，能够更清晰准确的写出代码，毕竟写一大堆 then 也很恶心，并且也能优雅地解决回调地狱问题。当然也存在一些缺点，因为 await 将异步代码改造成了同步代码，如果多个异步代码没有依赖性却使用了 await 会导致性能上的降低。 常用定时器函数 setTimeout、setInterval、requestAnimationFrame 各有什么特点？ setTimeout 由于 JS 是单线程执行的，如果前面的代码影响了性能，就会导致 setTimeout 不会按期执行。当然了，我们可以通过代码去修正 setTimeout，从而使定时器相对准确。 const message = document.getElementById(\"message\"); const count = 1000; function animate () { const start = +new Date(); message.innerHTML = count--; // 耗时操作 const finish = +new Date(); // 计算时间间隔 const time = 1000 - (finish - start); setTimeout(animate, time); } animate(); setInterval setInterval 作用和 setTimeout 基本一致，只是该函数是每隔一段时间执行一次回调函数。 通常来说不建议使用 setInterval。第一，它和 setTimeout 一样，不能保证在预期的时间执行任务。第二，它存在执行累积的问题，请看以下伪代码: function demo() { setInterval(function(){ console.log(2) },1000) sleep(2000) } demo() 以上代码在浏览器环境中，如果定时器执行过程中出现了耗时操作（sleep(2000)），多个回调函数会在耗时操作结束以后同时执行，这样可能就会带来性能上的问题。 requestAnimationFrame requestAnimationFrame 自带函数节流功能，基本可以保证在 16.6 毫秒内只执行一次（不掉帧的情况下），并且该函数的延时效果是精确的，没有其他定时器时间不准的问题。 function setInterval(callback, interval) { let timer const now = Date.now let startTime = now() let endTime = startTime const loop = () => { timer = window.requestAnimationFrame(loop) endTime = now() if (endTime - startTime >= interval) { startTime = endTime = now() callback(timer) } } timer = window.requestAnimationFrame(loop) return timer } let a = 0 setInterval(timer => { console.log(a++) if (a === 3) cancelAnimationFrame(timer) }, 1000) Copyright © TeamSecret 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-09-15 10:08:39 "},"basic/sync/Promise.html":{"url":"basic/sync/Promise.html","title":"手写 Promise","keywords":"","body":"手写 Promise 简易版 实现一个符合 Promise/A+ 规范的 Promise 改造 resolve 和 reject 函数 改造 then 函数中的代码 兼容多种 Promise 的 resolutionProcedure 函数 完整版 手写 Promise.all 手写 Promise.race 简易版 // 创建了三个常量用于表示状态，对于经常使用的一些值都应该通过常量来管理，便于开发及后期维护 const PENDING = 'pending' const RESOLVED = 'resolved' const REJECTED = 'rejected' function MyPromise (fn) { // 在函数体内部首先创建了常量 that，因为代码可能会异步执行，用于获取正确的 this 对象 const that = this // 一开始 Promise 的状态应该是 pending that.state = PENDING // value 变量用于保存 resolve 或者 reject 中传入的值 that.value = null // resolvedCallbacks 和 rejectedCallbacks 用于保存 then 中的回调 // 因为当执行完 Promise 时状态可能还是等待中，这时候应该把 then 中的回调保存起来用于状态改变时使用 that.resolvedCallbacks = [] that.rejectedCallbacks = [] function resolve (value) { // 判断当前状态是否为等待中，因为规范规定只有等待态才可以改变状态 if (that.state === PENDING) { // 将当前状态更改为对应状态 that.state = RESOLVED // 将传入的值赋值给 value that.value = value // 遍历回调数组并执行 that.resolvedCallbacks.map(cb => cb(that.value)) } } function reject (value) { if (that.state === PENDING) { that.state = REJECTED that.value = value that.rejectedCallbacks.map(cb => cb(that.value)) } } try { // 执行传入的函数并且将 resolve, reject 函数当做参数传进去 fn(resolve, reject) } catch (e) { // 捕获错误并且执行 reject 函数 reject(e) } } MyPromise.prototype.then = function (resolve, rejected) { // 保存 this const that = this // 给 resolve, rejected 指定默认值 const onFulfilled = typeof resolve === 'function' ? resolve : v => v const onRejected = typeof rejected === 'function' ? rejected : err => { throw err } if (that.state === PENDING) { that.resolvedCallbacks.push(onFulfilled) that.rejectedCallbacks.push(onRejected) } if (that.state === RESOLVED) { onFulfilled(that.value) } if (that.state === REJECTED) { onRejected(that.value) } } new MyPromise((resolve, reject) => { setTimeout(() => { resolve(1) }, 0) }).then(value => { console.log(value) }) 实现一个符合 Promise/A+ 规范的 Promise 改造 resolve 和 reject 函数 function resolve (value) { // 对于 resolve 函数来说，首先需要判断传入的值是否为 Promise 类型 if (value instanceof MyPromise) { return value.then(resolve, reject) } // 为了保证函数执行顺序，需要将函数体代码使用 setTimeout 包裹起来 setTimeout(() => { if (that.state === PENDING) { that.value = value that.state = RESOLVED that.resolvedCallbacks.map(cb => cb(that.value)) } }, 0); } function reject (value) { setTimeout(() => { if (that.state === PENDING) { that.value = value that.state = REJECTED that.rejectedCallbacks.map(cb => cb(that.value)) } }, 0); } 改造 then 函数中的代码 if (that.state === PENDING) { // 需要新增一个变量 promise2，因为每个 then 函数都需要返回一个新的 Promise 对象，该变量用于保存新的返回对象 // 返回了一个新的 Promise 对象，并在 Promise 中传入了一个函数 return (promise2 = new MyPromise((resolve, reject) => { that.resolvedCallbacks.push(() => { // 在执行函数的过程中可能会遇到错误，所以使用了 try...catch 包裹 try { // 规范规定，执行 onFulfilled 或者 onRejected 函数时会返回一个 x， // 并且执行 Promise 解决过程， // 这是为了不同的 Promise 都可以兼容使用，比如 JQuery 的 Promise 能兼容 ES6 的 Promise const x = onFulfilled(that.value) resolutionProcedure(promise2, x, resolve, reject) } catch (r) { reject(r) } }) that.rejectedCallbacks.push(() => { try { const x = onRejected(that.value) resolutionProcedure(promise2, x, resolve, reject) } catch (r) { reject(r) } }) })) } if (that.state === RESOLVED) { return (promise2 = new MyPromise((resolve, reject) => { setTimeout(() => { try { const x = onFulfilled(that.value) resolutionProcedure(promise2, x, resolve, reject) } catch (r) { reject(r) } }, 0); })) } if (that.state === REJECTED) { return (promise2 = new MyPromise((resolve, reject) => { setTimeout(() => { try { const x = onRejected(that.value) resolutionProcedure(promise2, x, resolve, reject) } catch (r) { reject(r) } }, 0); })) } 兼容多种 Promise 的 resolutionProcedure 函数 function resolutionProcedure (promise2, x resolve, reject) { // 规范规定了 x 不能与 promise2 相等，这样会发生循环引用的问题 if (promise2 === x) { return reject(new TypeError('Error')) } // 判断 x 的类型 // 如果 x 为 MyPromise ，则使 promise 接受 x 的状态 if (x instanceof MyPromise) { x.then(val => { resolutionProcedure(promise2, x, resolve,reject) }, reject) } // 创建一个变量 called 用于判断是否已经调用过函数 let called = false if (x !== null && (typeof x === 'object' || typeof x === 'function')) { // 当 x 的类型为 Object 或 Function 时 try { const { then } = x // 判断 then 的类型 if (typeof then === 'function') { // 当 then 为函数时 // 将 x 作为函数的作用域 this 调用 // 并且传递两个回调函数作为参数 // 第一个参数叫做 resolvePromise // 第二个参数叫做 rejectPromise // 两个回调函数都需要判断是否已经执行过函数，然后进行相应的逻辑 then.call( x, y => { if (called) { return } called = true resolutionProcedure(promise2, y, resolve, reject) }, e => { if (called) { return } called = true reject(e) } ) } else { // 当 then 不是函数时，就将 x 传入 resolve 中 resolve(x) } } catch (r) { if (called) { return } called = true reject(r) } } else { // 当 x 的类型不是对象和函数时，将 x 传入 resolve 中 resolve(x) } } 完整版 // 定义常量 const PENDING = 'pending' const RESOLVED = 'resolved' const REJECTED = 'rejected' function MyPromise (fn) { // 保存 this 对象 const that = this // 初始化状态 that.state = PENDING // 设置初始值 that.value = null // 回调状态数组 that.resolvedCallbacks = [] that.rejectedCallbacks = [] function resolve (value) { if (value instanceof MyPromise) { return value.then(resolve, reject) } setTimeout(() => { if (that.state === PENDING) { that.value = value that.state = RESOLVED that.resolvedCallbacks.map(cb => cb(that.value)) } }, 0); } function reject (value) { setTimeout(() => { if (that.state === PENDING) { that.value = value that.state = REJECTED that.rejectedCallbacks.map(cb => cb(that.value)) } }, 0); } try { fn(resolve, reject) } catch (e) { reject(e) } } MyPromise.prototype.then = function (resolve, reject) { const that = this const onFulfilled = typeof resolve === 'function' ? resolve : v => v const onRejected = typeof reject === 'function' ? reject : e => { throw e } if (that.state === PENDING) { return (promise2 = new MyPromise((resolve, reject) => { that.resolvedCallbacks.push(() => { try { const x = onFulfilled(that.value) resolutionProcedure(promise2, x, resolve, reject) } catch (e) { reject(e) } }) that.rejectedCallbacks.push(() => { try { const x = onRejected(that.value) resolutionProcedure(promise2, x, resolve, reject) } catch (e) { reject(e) } }) })) } if (that.state === RESOLVED) { return (promise2 = new MyPromise((resolve, reject) => { setTimeout(() => { try { const x = onFulfilled(that.value) resolutionProcedure(promise2, x, resolve, reject) } catch (e) { reject(e) } }, 0); })) } if (that.state === REJECTED) { return (promise2 = new MyPromise((resolve, reject) => { setTimeout(() => { try { const x = onRejected(that.value) resolutionProcedure(promise2, x, resolve, reject) } catch (e) { reject(e) } }, 0); })) } } function resolutionProcedure (promise2, x, resolve, reject) { if (promise2 === x) { return reject(new TypeError('Error')) } if (x instanceof MyPromise) { x.then( val => { resolutionProcedure(promise2, x, resolve, reject) }, reject ) } else { let called = false if (x !== null && (typeof x === 'object' || typeof x === 'function')) { try { const { then } = x if (typeof then === 'function') { then.call( x, y => { if (called) { return } called = true resolutionProcedure(promise2, y, resolve, reject) }, e => { if (called) { return } called = true reject(e) } ) } } catch (e) { if (called) { return } called = true reject(e) } } else { resolve(x) } } } 手写 Promise.all MyPromise.all = function (promiseArr) { // 声明一个数组，用于保存 promise 进行结果 const result = [] // 声明一个计数器 每一个 promise 返回就加 1 let count = 0 return new MyPromise((resolve, reject) => { for (let i = 0; i { // 这里不能直接 push 数组，要控制顺序一一对应 result[i] = res count++ // 只有全部的 promise 执行成功之后才 resolve 出去 if (count === promiseArr.length) { resolve(result) } }, err => { reject(err) } ) } }) } 手写 Promise.race MyPromise.race = function (promiseArr) { return new MyPromise((resolve, reject) => { for (let i = 0; i { // promise 数组只要有任何一个 promise 状态变更，就直接返回 resolve(res) }, err => { reject(err) } ) } }) } Copyright © TeamSecret 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-09-16 22:35:41 "},"basic/sync/EventLoop.html":{"url":"basic/sync/EventLoop.html","title":"Event Loop","keywords":"","body":"Event Loop 线程与进程 线程和进程的区别是什么？JS 单线程带来的好处？ 本质上来说，两个名词都是 CPU 工作时间片的一个描述。 进程描述了 CPU 在运行指令及加载和保存上下文所需的时间，放在应用上来说就代表了一个程序。 线程是进程中的更小单位，描述了执行一段指令所需的时间。 把这些概念拿到浏览器中来说，当你打开一个 Tab 页时，其实就是创建了一个进程，一个进程中可以有多个线程，比如渲染线程、JS 引擎线程、HTTP 请求线程等等。当你发起一个请求时，其实就是创建了一个线程，当请求结束后，该线程可能就会被销毁。 我们都知道，在 JS 运行的时候可能会阻止 UI 渲染，这说明了两个线程是互斥的。这其中的原因是因为 JS 可以修改 DOM，如果在 JS 执行的时候 UI 线程还在工作，就可能导致不能安全的渲染 UI。这其实也是一个单线程的好处，得益于 JS 是单线程运行的，可以达到节省内存，节约上下文切换时间，没有锁的问题的好处。当然前面两点在服务端中更容易体现，对于锁的问题，形象的来说就是当我读取一个数字 15 的时候，同时有两个线程对数字进行了加减，这时候结果就出现了错误。解决这个问题也不难，只需要在读取的时候加锁，直到读取完毕之前都不能进行写入操作。 为了利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作 DOM。所以，这个新标准并没有改变 JavaScript 单线程的本质。 执行栈 什么是执行栈？ 可以把执行栈认为是一个存储函数调用的栈结构，遵循先进后出的原则。 递归爆栈 当我们使用递归的时候，因为栈可存放的函数是有限制的，一旦存放了过多的函数且没有得到释放的话，就会出现爆栈的问题。 一个经典问题就是 Fibonacci 数列的实现: function fibonacci (n) { if (n === 0 || n === 1) { return n } return fibonacci(n - 1) + fibonacci(n - 2) } // ​fibonacci(100) 时浏览器就会卡死（栈溢出） console.log(fibonacci(100)) 可以通过尾调优化或者改写为循环的方式防止出现爆栈的情况。 浏览器中的 Event Loop 当我们执行 JS 代码的时候其实就是往执行栈中放入函数，那么遇到异步代码的时候该怎么办？其实当遇到异步的代码时，会被挂起并在需要执行的时候加入到 Task（有多种 Task） 队列中。一旦执行栈为空，Event Loop 就会从 Task 队列中拿出需要执行的代码并放入执行栈中执行，所以本质上来说 JS 中的异步还是同步行为。 不同的任务源会被分配到不同的 Task 队列中，任务源可以分为 微任务（microtask） 和 宏任务（macrotask）。在 ES6 规范中，microtask 称为 jobs，macrotask 称为 task。 Event Loop 执行顺序如下所示： 首先执行同步代码，这属于宏任务 当执行完所有同步代码后，执行栈为空，查询是否有异步代码需要执行 执行所有微任务 当执行完所有微任务后，如有必要会渲染页面 然后开始下一轮 Event Loop，执行宏任务中的异步代码，也就是 setTimeout 中的回调函数 下面来看以下代码的执行顺序： console.log('script start') async function async1() { await async2() console.log('async1 end') } async function async2() { console.log('async2 end') } async1() setTimeout(function() { console.log('setTimeout') }, 0) new Promise(resolve => { console.log('Promise') resolve() }) .then(function() { console.log('promise1') }) .then(function() { console.log('promise2') }) console.log('script end') // script start => async2 end => Promise => script end => async1 end => promise1 => promise2 => setTimeout 首先先来解释下上述代码的 async 和 await 的执行顺序。当我们调用 async1 函数时，会马上输出 async2 end，并且函数返回一个 Promise，接下来在遇到 await 的时候会就让出线程开始执行 async1 外的代码，所以我们完全可以把 await 看成是让出线程的标志。 然后当同步代码全部执行完毕以后，就会去执行所有的异步代码，那么又会回到 await 的位置执行返回的 Promise 的 resolve 函数，这又会把 resolve 丢到微任务队列中，接下来去执行 then 中的回调，当两个 then 中的回调全部执行完毕以后，又会回到 await 的位置处理返回值，这时候你可以看成是 Promise.resolve(返回值).then()，然后 await 后的代码全部被包裹进了 then 的回调中，所以 console.log('async1 end') 会优先执行于 setTimeout。 微任务包括 process.nextTick ，promise ，MutationObserver，Object.observe ，其中 process.nextTick 为 Node 独有。 宏任务包括 script ， setTimeout ，setInterval ，UI rendering， requestAnimationFrame，setImmediate ，I/O。 Node 中的 Event Loop Node 的 Event Loop 分为 6 个阶段，它们会按照顺序反复运行。每当进入某一个阶段的时候，都会从对应的回调队列中取出函数去执行。当队列为空或者执行的回调函数数量到达系统设定的阈值，就会进入下一阶段。 各个阶段执行的任务如下： timers 阶段：这个阶段执行 setTimeout 和 setInterval 预定的 callback I/O callback 阶段：执行除了 close 事件的 callbacks、被 timers 设定的 callbacks、setImmediate() 设定的 callbacks 这些之外的 callbacks idle, prepare 阶段：仅 node 内部使用 poll 阶段：获取新的 I/O 事件，适当的条件下 node 将阻塞在这里 poll 是一个至关重要的阶段，这一阶段中，系统会做两件事情 回到 timer 阶段执行回调 执行 I/O 回调 并且在进入该阶段时如果没有设定 timer 的话，会发生以下两件事情 如果 poll 队列不为空，会遍历回调队列并同步执行，直到队列为空或者达到系统限制 如果 poll 队列为空时，会有两件事发生 如果有 setImmediate 回调需要执行，poll 阶段会停止并且进入到 check 阶段执行回调 如果没有 setImmediate 回调需要执行，会等待回调被加入到队列中并立即执行回调，这里同样会有个超时时间设置防止一直等待下去 设定了 timer 的话且 poll 队列为空，则会判断是否有 timer 超时，如果有的话会回到 timer 阶段执行回调。 check 阶段：执行 setImmediate() 设定的 callbacks close callbacks 阶段：执行 socket.on('close', ....) 这些 callbacks 接下来通过代码来深入理解这块内容。 首先在有些情况下，定时器的执行顺序其实是随机的: setTimeout(() => { console.log('setTimeout') }, 0) setImmediate(() => { console.log('setImmediate') }) 对于以上代码来说，setTimeout 可能执行在前，也可能执行在后 首先 setTimeout(fn, 0) === setTimeout(fn, 1)，这是由源码决定的 进入事件循环也是需要成本的，如果在准备时候花费了大于 1ms 的时间，那么在 timer 阶段就会直接执行 setTimeout 回调 那么如果准备时间花费小于 1ms，那么就是 setImmediate 回调先执行了 当然在某些情况下，他们的执行顺序一定是固定的，比如以下代码： const fs = require('fs') fs.readFile(__filename, () => { setTimeout(() => { console.log('timeout'); }, 0) setImmediate(() => { console.log('immediate') }) }) 在上述代码中，setImmediate 永远先执行。因为两个代码写在 IO 回调中，IO 回调是在 poll 阶段执行，当回调执行完毕后队列为空，发现存在 setImmediate 回调，所以就直接跳转到 check 阶段去执行回调了。 上面介绍的都是 macrotask 的执行情况，对于 microtask 来说，它会在以上每个阶段完成前清空 microtask 队列。 // 对于这段代码来说，和浏览器中的输出是一样的，microtask 永远执行在 macrotask 前面。 setTimeout(() => { console.log('timer') }, 0) Promise.resolve().then(function() { console.log('promise') }) // promise => timer 最后我们来讲讲 Node 中的 process.nextTick，这个函数其实是独立于 Event Loop 之外的，它有一个自己的队列，当每个阶段完成后，如果存在 nextTick 队列，就会清空队列中的所有回调函数，并且优先于其他 microtask 执行。 // 对于这段代码，无论如何，永远都是先把 nextTick 全部打印出来。 setTimeout(() => { console.log('timer') Promise.resolve().then(function() { console.log('promise') }) }, 0) process.nextTick(() => { console.log('nextTick') process.nextTick(() => { console.log('nextTick') process.nextTick(() => { console.log('nextTick') process.nextTick(() => { console.log('nextTick') }) }) }) }) Copyright © TeamSecret 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-09-16 22:23:09 "},"basic/garbage/":{"url":"basic/garbage/","title":"垃圾回收机制","keywords":"","body":"垃圾回收机制 V8 下的垃圾回收机制是怎么样的？ V8 实现了准确式 GC，GC 算法采用了分代式垃圾回收机制。因此，V8 将内存（堆）分为新生代和老生代两部分。 新生代算法 新生代中的对象一般存活时间较短，使用 Scavenge GC 算法。 在新生代空间中，内存空间分为两部分，分别为 From 空间和 To 空间。在这两个空间中，必定有一个空间是使用的，另一个空间是空闲的。新分配的对象会被放入 From 空间中，当 From 空间被占满时，新生代 GC 就会启动了。算法会检查 From 空间中存活的对象并复制到 To 空间中，如果有失活的对象就会销毁。当复制完成后将 From 空间和 To 空间互换，这样 GC 就结束了。 老生代算法 老生代中的对象一般存活时间较长且数量也多，使用了两个算法，分别是标记清除算法和标记压缩算法 在讲算法前，先来说下什么情况下对象会出现在老生代空间中： 新生代中的对象是否已经经历过一次 Scavenge 算法，如果经历过的话，会将对象从新生代空间移到老生代空间中。 To 空间的对象占比大小超过 25 %。在这种情况下，为了不影响到内存分配，会将对象从新生代空间移到老生代空间中。 老生代中的空间很复杂，有如下几个空间： enum AllocationSpace { // TODO(v8:7464): Actually map this space's memory as read-only. RO_SPACE, // 不变的对象空间 NEW_SPACE, // 新生代用于 GC 复制算法的空间 OLD_SPACE, // 老生代常驻对象空间 CODE_SPACE, // 老生代代码对象空间 MAP_SPACE, // 老生代 map 对象 LO_SPACE, // 老生代大空间对象 NEW_LO_SPACE, // 新生代大空间对象 FIRST_SPACE = RO_SPACE, LAST_SPACE = NEW_LO_SPACE, FIRST_GROWABLE_PAGED_SPACE = OLD_SPACE, LAST_GROWABLE_PAGED_SPACE = MAP_SPACE }; 在老生代中，以下情况会先启动标记清除算法： 某一个空间没有分块的时候 空间中被对象超过一定限制 空间不能保证新生代中的对象移动到老生代中 在这个阶段中，会遍历堆中所有的对象，然后标记活的对象，在标记完成后，销毁所有没有被标记的对象。在标记大型对内存时，可能需要几百毫秒才能完成一次标记。这就会导致一些性能上的问题。为了解决这个问题，2011 年，V8 从 stop-the-world 标记切换到增量标志。在增量标记期间，GC 将标记工作分解为更小的模块，可以让 JS 应用逻辑在模块间隙执行一会，从而不至于让应用出现停顿情况。但在 2018 年，GC 技术又有了一个重大突破，这项技术名为并发标记。该技术可以让 GC 扫描和标记对象时，同时允许 JS 运行，你可以点击 该博客 详细阅读。 清除对象后会造成堆内存出现碎片的情况，当碎片超过一定限制后会启动压缩算法。在压缩过程中，将活的对象向一端移动，直到所有对象都移动完成然后清理掉不需要的内存。 Copyright © TeamSecret 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-09-22 20:47:14 "},"browser/event/":{"url":"browser/event/","title":"事件机制","keywords":"","body":"浏览器事件机制 事件冒泡与事件捕获 事件的触发过程是怎么样的？ 事件冒泡 微软提出了名为事件冒泡(event bubbling)的事件流。事件会从最内层的元素开始发生，一直向上传播，直到 document 对象。 因此在事件冒泡的概念下在 p 元素上发生 click 事件的顺序应该是 p -> body -> html -> document 事件捕获 网景提出另一种事件流名为事件捕获(event capturing)。与事件冒泡相反，事件会从最外层开始发生，直到最具体的元素。 因此在事件捕获的概念下在 p 元素上发生 click 事件的顺序应该是 document -> html -> body -> div -> p addEventListener 的第三个参数 网景和微软对于事件流处理的理念并不相同，后来 w3c 采用折中的方式，制定了统一的标准 —— 先捕获再冒泡。 addEventListener 的第三个参数就是为冒泡和捕获准备的。 addEventListener 有三个参数： element.addEventListener(event, function, useCapture) 第一个参数是需要绑定的事件 第二个参数是触发事件后要执行的函数 第三个参数默认值是 false，表示在事件冒泡阶段调用事件处理函数；如果参数为true，则表示在事件捕获阶段调用处理函数。 事件触发的三个阶段 document 往事件触发处传播，遇到注册的捕获事件会触发 传播到事件触发处时触发注册的事件 从事件触发处往 document 传播，遇到注册的冒泡事件会触发 事件触发一般来说会按照上面的顺序进行，但是也有特例，如果给一个 body 中的子节点同时注册冒泡和捕获事件，事件触发会按照注册的顺序执行。 总结起来就是： 对于非 事件绑定 节点则先执行捕获在执行冒泡 对于 事件绑定 节点则是先注册的事件先执行，无论冒泡还是捕获 outer inner // 给外层节点绑定冒泡事件 outer.addEventListener(\"click\",function(e){ console.log(\"outer 冒泡事件\"); },false); // 给内层节点绑定冒泡事件 inner.addEventListener(\"click\",function(e){ console.log(\"inner 冒泡事件\"); },false); // 给外层节点绑定捕获事件 outer.addEventListener(\"click\",function(e){ console.log(\"outer 捕获事件\"); },true); // 给内层节点绑定捕获事件 inner.addEventListener(\"click\",function(e){ console.log(\"inner 捕获事件\"); },true); 这里大体分析下执行结果： 点击 outer，click 事件从 document -> html -> body -> outer -> inner (捕获前进) 这里在 outer 上发现了捕获注册事件，则输出\"outer 捕获事件\" 到达 inner，已经到达目的节点，inner 上先注册的冒泡后注册的捕获，则先执行冒泡，输出\"inner 冒泡事件\"。再在 inner 上执行后注册的捕获事件，输出\"inner 捕获事件\" 下面进入冒泡阶段，按照 inner -> outer -> body -> html -> document (冒泡前进) 在 outer 上发现了冒泡事件，则输出\"outer 冒泡事件\" 在最新版的 Chrome 浏览器中，会先执行所有节点的捕获事件，再执行冒泡事件 阻止事件冒泡 如果需要阻止事件冒泡，可以调用以下方法： event.stopPropagation() 当有 event 对象时，阻止事件冒泡。 window.event.cancelBubble = true 当没有 event 对象时，阻止事件冒泡（一般用在IE浏览器）。 event.stopImmediatePropagation() 阻止同一个事件的其他监听函数被调用。比如对同一个元素绑定了两个 click 事件，如果在第一个 click 事件写了 event.stopImmediatePropagation()，那么它的其他点击事件就都不会被触发。 事件代理 什么是事件代理（事件委托） 有什么好处? 事件委托的原理：不给每个子节点单独设置事件监听器，而是设置在其父节点上，然后利用冒泡原理设置每个子节点。 事件代理的方式相较于直接给目标注册事件来说，有以下优点： 减少内存消耗和 dom 操作，提高性能 动态绑定事件（因为事件绑定在父级元素，所以新增的元素也能触发同样的事件） 不需要给子节点注销事件 添加 li 元素 1 2 3 const add = document.getElementById('add') const ul = document.getElementById('ul') // 点击按钮，给 ul 动态添加子元素 add.addEventListener('click', () => { const li = document.createElement('li') li.innerText = ul.childElementCount + 1 ul.appendChild(li) }) // 给父元素绑定一次点击事件 ul.addEventListener('click', e => { // 点击子元素输出对应的数字 console.log(e.target.innerText) }) Copyright © TeamSecret 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-09-27 12:26:48 "},"browser/crossDomain/":{"url":"browser/crossDomain/","title":"跨域","keywords":"","body":"跨域 因为浏览器出于安全考虑（主要是用来防止 CSRF（Cross-site request forgery） 攻击的。简单点说，CSRF 攻击是利用用户的登录态发起恶意请求。），有同源策略。也就是说，如果协议、域名或者端口有一个不同就是跨域，Ajax 请求会失败。 跨域解决方法 图像 Ping JSONP document.domain + Iframe window.location.hash + Iframe window.name + Iframe postMessage Websocket Nginx 反向代理 Node 正向代理 CORS 图像 Ping 利用 标签没有跨域限制，与服务器进行简单、单向的跨域通信。 通过这种方式，浏览器得不到任何具体的数据，只能通过监听 load 和 error 事件，知道响应是什么时候接收到的。 const img = new Image() img.onload = img.onerror = function () { // 服务器响应 console.log('Done!') } img.src = 'http://domain/api?param1=a&param2=b' JSONP JSONP 的原理很简单，就是利用 标签没有跨域限制的漏洞。通过 标签指向一个需要访问的地址并提供一个回调函数来接收数据。 function jsonp(data) { console.log(data) } document.domain + Iframe 该方式只能用于二级域名相同的情况下，比如 a.test.com 和 b.test.com 适用于该方式。 只需要给页面添加 document.domain = 'test.com' 表示二级域名都相同就可以实现跨域。 Hello A document.domain = \"test.com\"; function load() { console.log(frame.contentWindow.a); } Hello B document.domain = \"test.com\"; var a = 100; window.location.hash + Iframe 原理就是通过 url 带 hash，通过一个非跨域的中间页面来传递数据。 一开始 a.html 给 c.html 传一个 hash 值，然后 c.html 收到 hash 值后，再把 hash 值传递给 b.html，最后 b.html 将结果放到 a.html 的 hash 值中。其中 a.html 和 b.html 是同域的，都是 http://localhost:8000，而 c.html 是 http://localhost:8080 console.log(location.hash); window.onhashchange = function() { console.log(location.hash); }; window.parent.parent.location.hash = location.hash; console.log(location.hash); const iframe = document.createElement(\"iframe\"); iframe.src = \"http://localhost:8000/hash/b.html#name2\"; document.body.appendChild(iframe); window.name + Iframe window 对象的 name 属性是一个很特别的属性，当该 window 的 location 变化，然后重新加载，它的 name 属性可以依然保持不变。 通过 iframe 的 src 属性由外域转向本地域，跨域数据即由 iframe 的 window.name 从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。 其中 a.html 和 b.html 是同域的，都是 http://localhost:8000，而 c.html 是 http://localhost:8080 const iframe = document.getElementById('iframe') let first = true; // onload事件会触发2次，第1次加载跨域页，并留存数据于 window.name function load() { if (first) { // 第1次 onload(跨域页) 成功后，切换到同域代理页面 iframe.src = \"http://localhost:8000/name/b.html\"; first = false; } else { // 第2次 onload(同域 b.html 页) 成功后，读取同域 window.name 中数据 console.log(iframe.contentWindow.name); } } b.html 为中间代理页，与 a.html 同域，内容为空。 window.name = \"data\"; postMessage window.postMessage() 方法可以安全地实现跨源通信。通常，对于两个不同页面的脚本，只有当执行它们的页面位于具有相同的协议（通常为 https），端口号（443 为 https 的默认值），以及主机 (两个页面的 Document.domain 设置为相同的值) 时，这两个脚本才能相互通信。window.postMessage() 方法提供了一种受控机制来规避此限制，只要正确的使用，这种方法就很安全。 这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息。 语法 otherWindow.postMessage(message, targetOrigin, [transfer]); otherWindow: 其他窗口的一个引用，比如 iframe 的 contentWindow 属性、执行 window.open 返回的窗口对象、或者是命名过或数值索引的 window.frames。 message: 将要发送到其他 window 的数据。 targetOrigin: 通过窗口的 origin 属性来指定哪些窗口能接收到消息事件。 transfer(可选) : 是一串和 message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。 function load() { const iframe = document.getElementById('iframe') iframe.contentWindow.postMessage(\"post data\", \"http://localhost:8080\"); window.onmessage = e => { console.log(e.data); // post data from target.html }; } hello window.onmessage = e => { console.log(e.data); // post data e.source.postMessage(e.data + ' from target.html', e.origin); }; Websocket WebSocket 规范定义了一种 API，可在网络浏览器和服务器之间建立“套接字”连接。简单地说：客户端和服务器之间存在持久的连接，而且双方都可以随时开始发送数据。 Websocket 使用 ws/wss 协议, 因此没有跨域的限制。 // 创建 WebSocket 连接 let socket = new WebSocket(\"ws://localhost:8080\"); // 发送数据 socket.onopen = function() { socket.send(\"send data\"); }; // 接收数据 socket.onmessage = function(e) { console.log(e.data); }; const WebSocket = require(\"ws\"); const server = new WebSocket.Server({ port: 8080 }); server.on(\"connection\", function(socket) { socket.on(\"message\", function(data) { socket.send(data); }); }); Nginx 反向代理 反向代理（Reverse Proxy）方式是指以代理服务器来接受 internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 internet 上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。 使用步骤 安装 Nginx 安装 Nginx 官方指引 准备服务端接口 // api.js const http = require('http'); const fs = require('fs'); const url = require('url'); const port = 8888 const server = http.createServer(function (req, res) { if (req.url === '/favicon.ico') { return; } const parseUrl = url.parse(req.url, true); console.log('parseUrl', parseUrl.pathname) if (parseUrl.pathname === '/api/getList') { const list = {'a': 1, 'b': 2} res.writeHead(200, {'content-Type':'text/html;charset=UTF-8'}) res.end(JSON.stringify(list)) } else { res.write(` port: ${port}`) res.end() } }); server.listen(port, function () { console.log('server is starting on port ' + port); }); node api.js 运行后，访问 http://localhost:8888/api/getList 即可看到输出的 JSON 对象。 准备前端页面 test sendAjax var sendAjax = () => { var xhr = new XMLHttpRequest(); xhr.open('GET', '/api/getList', true); xhr.send(); xhr.onreadystatechange = function (e) { if (xhr.readyState == 4 && xhr.status == 200) { console.log(xhr.responseText); } }; } 部署前端页面到 Nginx 服务器 以 Ubuntu 为例： 找到 /etc/nginx/sites-available/default 文件，可以看到里面定义的 root /var/www/html; 表示 Nginx 服务器的根目录位于 /var/www/html。 将前端页面 index.html 复制到此目录中。 浏览器访问 http://本机 IP 。可以看到页面已经更新了，但此时点击按钮会发现接口调用报 404，这是因为我们还没有配置代理。 配置反向代理 以管理员权限编辑 /etc/nginx/sites-available/default 文件。在 server 配置项中新增以下内容： # 以 /api/ 开头的接口将匹配这条规则 location /api/ { # 将接口代理到后端地址 proxy_pass http://localhost:8888; } 重启 Nginx nginx -s reload 命令重启 Nginx。再到页面上调用接口即可正常访问。 Node 正向代理 代理的思路为，利用服务端请求不会跨域的特性，让接口和当前站点同域。 代理前 代理后 这样，所有的资源以及请求都在一个域名下了。 以 Vue-cli 3.x 为例： // vue.config.js module.exports = { devServer: { port: 8000, proxy: { \"/api\": { target: \"http://localhost:8080\" } } } }; CORS 跨域资源共享(CORS) 是一种机制，它使用额外的 HTTP 头来告诉浏览器 让运行在一个 origin (domain) 上的 Web 应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器不同的域、协议或端口请求一个资源时，资源会发起一个跨域 HTTP 请求。 CORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现。 浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。 服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。 app.use(async (ctx, next) => { ctx.set(\"Access-Control-Allow-Origin\", ctx.headers.origin); ctx.set(\"Access-Control-Allow-Credentials\", true); ctx.set(\"Access-Control-Request-Method\", \"PUT,POST,GET,DELETE,OPTIONS\"); ctx.set( \"Access-Control-Allow-Headers\", \"Origin, X-Requested-With, Content-Type, Accept, cc\" ); if (ctx.method === \"OPTIONS\") { ctx.status = 204; return; } await next(); }); 也可以直接使用中间件 const cors = require(\"koa-cors\"); app.use(cors()); 通过 CORS 这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为简单请求和复杂请求。 简单请求 以 Ajax 为例，当满足以下条件时，会触发简单请求 使用下列方法之一（意思就是以下请求意外的都是非简单请求）： GET HEAD POST Content-Type 的值仅限于下列三者之一（例如 application/json 为非简单请求）： text/plain multipart/form-data application/x-www-form-urlencoded 人为设置以下集合外的请求头 Accept Accept-Language Content-Language Content-Type（需要注意额外的限制） DPR Downlink Save-Data Viewport-Width Width 请求中的任意 XMLHttpRequestUpload 对象均没有注册任何事件监听器； XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问。 请求中没有使用 ReadableStream 对象。 复杂请求 除以上情况外的，就是复杂请求。 对于复杂请求来说，首先会发起一个预检请求，该请求是 options 方法的，通过该请求来知道服务端是否允许跨域请求。 在新版的 chrome 中，如果你发送了复杂请求，却看不到 options 请求。可以在这里设置 chrome://flags/#out-of-blink-cors 设置成 disable ，重启浏览器。对于非简单请求就能看到 options 请求了。 关于 CORS 的 cookie 问题 默认情况下， 跨域请求不能发送和接收 cookie。想要传递 cookie 需要满足 3 个条件： web 请求设置 withCredentials 为 true // 原生 xml 的设置方式 var xhr = new XMLHttpRequest(); xhr.withCredentials = true; // axios 设置方式 axios.defaults.withCredentials = true; 服务端设置 Access-Control-Allow-Credentials 为 true Access-Control-Allow-Origin 不能设置为通配符 * Copyright © TeamSecret 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-09-28 12:53:48 "},"browser/storage/":{"url":"browser/storage/","title":"存储","keywords":"","body":"存储 有几种方式可以实现存储功能，分别有什么优缺点？ cookie，localStorage，sessionStorage，indexDB 特性 cookie localStorage sessionStorage indexDB 数据生命周期 一般由服务器生成，可以设置过期时间 除非被清理，否则一直存在 页面关闭就清理 除非被清理，否则一直存在 数据存储大小 4K 5M 5M 无限 与服务端通信 每次都会携带在 header 中，对于请求性能影响 不参与 不参与 不参与 从上表可以看到，cookie 已经不建议用于存储。如果没有大量数据存储需求的话，可以使用 localStorage 和 sessionStorage 。对于不怎么改变的数据尽量使用 localStorage 存储，否则可以用 sessionStorage 存储。 对于 cookie 来说，我们还需要注意安全性。 属性 作用 value 如果用于保存用户登录态，应该将该值加密，不能使用明文的用户标识 http-only 不能通过 JS 访问 Cookie，减少 XSS 攻击 secure 只能在协议为 HTTPS 的请求中携带 same-site 规定浏览器不能在跨站请求中携带 Cookie，减少 CSRF 攻击 Service Worker Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker 的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。 Service Worker 实现缓存功能一般分为三个步骤：首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。 具体使用教程可以参考这篇文章 Copyright © TeamSecret 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-09-28 13:26:17 "},"browser/cache/":{"url":"browser/cache/","title":"缓存机制","keywords":"","body":"缓存机制 缓存可以说是性能优化中简单高效的一种优化方式了，它可以显著减少网络传输所带来的损耗。 对于一个数据请求来说，可以分为发起网络请求、后端处理、浏览器响应三个步骤。浏览器缓存可以帮助我们在第一和第三步骤中优化性能。比如说直接使用缓存而不发起请求，或者发起了请求但后端存储的数据和前端一致，那么就没有必要再将数据回传回来，这样就减少了响应数据。 缓存位置 从缓存位置上来说分为四种，并且各自有优先级，当依次查找缓存且都没有命中的时候，才会去请求网络 Service Worker Memory Cache Disk Cache Push Cache 网络请求 Service Worker Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。 当 Service Worker 没有命中缓存的时候，我们需要去调用 fetch 函数获取数据。也就是说，如果我们没有在 Service Worker 命中缓存的话，会根据缓存查找优先级去查找数据。但是不管我们是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示我们是从 Service Worker 中获取的内容。 Memory Cache Memory Cache 也就是内存中的缓存，读取内存中的数据肯定比磁盘快。但是内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。 一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。 当我们访问过页面以后，再次刷新页面，可以发现很多数据都来自于内存缓存。 对于大文件来说，大概率是不存储在内存中的，反之优先 当前系统内存使用率高的话，文件优先存储进硬盘 Disk Cache Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上。 在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。 Push Cache Push Cache 是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。并且缓存时间也很短暂，只在会话（Session）中存在，一旦会话结束就被释放。 所有的资源都能被推送，但是 Edge 和 Safari 浏览器兼容性不怎么好 可以推送 no-cache 和 no-store 的资源 一旦连接被关闭，Push Cache 就被释放 多个页面可以使用相同的 HTTP/2 连接，也就是说能使用同样的缓存 Push Cache 中的缓存只能被使用一次 浏览器可以拒绝接受已经存在的资源推送 你可以给其他域名推送资源 网络请求 如果所有缓存都没有命中的话，那么只能发起请求来获取资源了。 那么为了性能上的考虑，大部分的接口都应该选择好缓存策略。 缓存策略 通常浏览器缓存策略分为两种：强缓存和协商缓存，并且缓存策略都是通过设置 HTTP Header 来实现的。 强缓存 强缓存可以通过设置两种 HTTP Header 实现：Expires 和 Cache-Control 。强缓存表示在缓存期间不需要请求，state code 为 200。 Expires Expires: Wed, 22 Oct 2018 08:41:00 GMT Expires 是 HTTP/1 的产物，表示资源会在 Wed, 22 Oct 2018 08:41:00 GMT 后过期，需要再次请求。并且 Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效。 Cache-control Cache-control: max-age=30 Cache-Control 出现于 HTTP/1.1，优先级高于 Expires 。该属性值表示资源会在 30 秒后过期，需要再次请求。 Cache-Control 可以在请求头或者响应头中设置，并且可以组合使用多种指令 从图中我们可以看到，我们可以将多个指令配合起来一起使用，达到多个目的。比如说我们希望资源能被缓存下来，并且是客户端和代理服务器都能缓存，还能设置缓存失效时间等等。 Cache-Control 常见指令的作用： 指令 作用 public 表示响应可以被客户端和代理服务器缓存 private 表示响应只可以被客户端缓存 max-age=30 缓存 30 秒后就过期，需要重新请求 s-maxage=30 覆盖 max-age，作用一样，只在代理服务器中生效 no-store 不缓存任何响应 no-cache 资源被缓存，但是立即实效，下次会发起请求验证资源是否过期 max-state=30 30 秒内，即使缓存过期，也使用该缓存 min-fresh=30 希望在 30 秒内获取最新的响应 协商缓存 如果缓存过期了，就需要发起请求验证资源是否有更新。协商缓存可以通过设置两种 HTTP Header 实现：Last-Modified 和 ETag 。 当浏览器发起请求验证资源时，如果资源没有改变，那么服务端就会返回 304 状态码，并且更新浏览器缓存有效期。 Last-Modified 和 If-Modified-Since Last-Modified 表示本地文件最后修改日期，If-Modified-Since 会将 Last-Modified 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来，否则返回 304 状态码。 但是 Last-Modified 存在一些弊端： 如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 Last-Modified 被修改，服务端不能命中缓存导致发送相同的资源 因为 Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源 因为以上这些弊端，所以在 HTTP / 1.1 出现了 ETag 。 ETag 和 If-None-Match ETag 类似于文件指纹，If-None-Match 会将当前 ETag 发送给服务器，询问该资源 ETag 是否变动，有变动的话就将新的资源发送回来。并且 ETag 优先级比 Last-Modified 高。 最后，如果什么缓存策略都没设置，那么浏览器会怎么处理？ 对于这种情况，浏览器会采用一个启发式的算法，通常会取响应头中的 Date 减去 Last-Modified 值的 10% 作为缓存时间。 Copyright © TeamSecret 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-09-28 15:01:50 "},"browser/render/":{"url":"browser/render/","title":"浏览器渲染原理","keywords":"","body":"浏览器渲染原理 浏览器接收到 HTML 文件并转换为 DOM 树 当我们打开一个网页时，浏览器都会去请求对应的 HTML 文件。虽然平时我们写代码时都会分为 JS、CSS、HTML 文件，也就是字符串，但是计算机硬件是不理解这些字符串的，所以在网络中传输的内容其实都是 0 和 1 这些字节数据。当浏览器接收到这些字节数据以后，它会将这些字节数据转换为字符串，也就是我们写的代码。 字节数据 => 字符串 当数据转换为字符串以后，浏览器会先将这些字符串通过词法分析转换为标记（token），这一过程在词法分析中叫做标记化（tokenization）。 字节数据 => 字符串 => Token 那么什么是标记呢？这其实属于编译原理这一块的内容了。简单来说，标记还是字符串，是构成代码的最小单位。这一过程会将代码分拆成一块块，并给这些内容打上标记，便于理解这些最小单位的代码是什么意思 当结束标记化后，这些标记会紧接着转换为 Node，最后这些 Node 会根据不同 Node 之前的联系构建为一颗 DOM 树。 以上就是浏览器从网络中接收到 HTML 文件然后一系列的转换过程。 字节数据 => 字符串 => Token => Node => DOM 当然，在解析 HTML 文件的时候，浏览器还会遇到 CSS 和 JS 文件，这时候浏览器也会去下载并解析这些文件。 将 CSS 文件转换为 CSSOM 树 其实转换 CSS 到 CSSOM 树的过程和上一小节的过程是极其类似的 字节数据 => 字符串 => Token => Node => CSSOM 在这一过程中，浏览器会确定下每一个节点的样式到底是什么，并且这一过程其实是很消耗资源的。因为样式你可以自行设置给某个节点，也可以通过继承获得。在这一过程中，浏览器得递归 CSSOM 树，然后确定具体的元素到底是什么样式。 举个例子: span { color: red; } div > a > span { color: red; } 对于第一种设置样式的方式来说，浏览器只需要找到页面中所有的 span 标签然后设置颜色，但是对于第二种设置样式的方式来说，浏览器首先需要找到所有的 span 标签，然后找到 span 标签上的 a 标签，最后再去找到 div 标签，然后给符合这种条件的 span 标签设置颜色，这样的递归过程就很复杂。所以我们应该尽可能的避免写过于具体的 CSS 选择器，然后对于 HTML 来说也尽量少的添加无意义标签，保证层级扁平。 生成渲染树 当我们生成 DOM 树和 CSSOM 树以后，就需要将这两棵树组合为渲染树。 在这一过程中，不是简单的将两者合并就行了。渲染树只会包括需要显示的节点和这些节点的样式信息，如果某个节点是 display: none 的，那么就不会在渲染树中显示。 当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流），然后调用 GPU 绘制，合成图层，显示在屏幕上。 为什么操作 DOM 慢？ 想必大家都听过操作 DOM 性能很差，但是这其中的原因是什么呢？ 因为 DOM 是属于渲染引擎中的东西，而 JS 又是 JS 引擎中的东西。当我们通过 JS 操作 DOM 的时候，其实这个操作涉及到了两个线程之间的通信，那么势必会带来一些性能上的损耗。操作 DOM 次数一多，也就等同于一直在进行线程之间的通信，并且操作 DOM 可能还会带来重绘回流的情况，所以也就导致了性能上的问题。 什么情况阻塞渲染? 首先渲染的前提是生成渲染树，所以 HTML 和 CSS 肯定会阻塞渲染。如果你想渲染的越快，你越应该降低一开始需要渲染的文件大小，并且扁平层级，优化选择器。 然后当浏览器在解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。 当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性。 defer 属性：表明脚本在执行时不会影响页面的构造。也就是说，脚本会被延迟到整个页面都解析完毕后再执行。相当于告诉浏览器立即下载，延迟执行。 async 属性：async 属性告诉浏览器立即下载文件，如果存在多个 async 脚本，则谁先下载完谁先执行。指定 async 属性的目的是为了不让页面等待脚本的下载和执行，从而异步加载页面其他内容。因此，建议异步脚本不要再加载期间修改 DOM 。异步脚本一定会在页面的 load 事件前执行。 重绘（Repaint）和回流（Reflow） 重绘和回流会在我们设置节点样式时频繁出现，同时也会很大程度上影响性能。 重绘是当节点需要更改外观而不会影响布局的，比如改变 color 就叫称为重绘 回流是布局或者几何属性需要改变就称为回流。 回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流。 以下几个动作可能会导致性能问题： 改变 window 大小 改变字体 添加或删除样式 文字改变 定位或者浮动 盒模型 并且重绘和回流其实也和 Event Loop 有关。 当 Event Loop 执行完 Microtasks 后，会判断 document 是否需要更新，如果浏览器是 60Hz 的刷新率，那么就是 16.6ms 才会更新一次。 然后判断是否有 resize 或者 scroll 事件，有的话会去触发事件，所以 resize 和 scroll 事件也是至少 16ms 才会触发一次，并且自带节流功能。 判断是否触发了 media query 更新动画并且发送事件 判断是否有全屏操作事件 执行 requestAnimationFrame 回调 执行 IntersectionObserver 回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好 更新界面 以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行 requestIdleCallback 回调。 如何减少重绘和回流的次数？ 使用 transform 替代 top .test { position: absolute; top: 10px; width: 100px; height: 100px; background: red; } setTimeout(() => { // 引起回流 document.querySelector('.test').style.top = '100px' }, 1000) 使用 visibility: hidden 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局） 不要把节点的属性值放在一个循环里当成循环里的变量 for(let i = 0; i 不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局 动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrame CSS 选择符从右往左匹配查找，避免节点层级过多 将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点。比如对于 video 标签来说，浏览器会自动将该节点变为图层。 设置节点为图层的方式有很多，我们可以通过以下几个常用属性可以生成新图层： will-change video、iframe 标签 Copyright © TeamSecret 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-10-16 22:07:01 "},"browser/safe/":{"url":"browser/safe/","title":"前端安全问题","keywords":"","body":"前端安全问题 Iframe 如何让自己的网站不被其他网站的 iframe 引用？ // 检测当前网站是否被第三方 iframe 引用 // 若相等证明没有被第三方引用，若不等证明被第三方引用。当发现被引用时强制跳转百度。 if(top.location != self.location){ top.location.href = 'http://www.baidu.com' } 如何禁止引用的 iframe 对当前网站的某些操作？ sandbox 是 html5 的新属性，主要是提高 iframe 安全系数。 iframe 因安全问题而臭名昭著，这主要是因为 iframe 常被用于嵌入到第三方中，然后执行某些恶意操作。 现在有一场景：我的网站需要 iframe 引用某网站，但是不想被该网站操作 DOM、不想加载某些 js（广告、弹框等）、当前窗口被强行跳转链接等，我们可以设置 sandbox 属性。如使用多项用空格分隔。 allow-same-origin：允许被视为同源，即可操作父级 DOM 或 cookie 等 allow-top-navigation：允许当前 iframe 的引用网页通过 url 跳转链接或加载 allow-forms：允许表单提交 allow-scripts：允许执行脚本文件 allow-popups：允许浏览器打开新窗口进行跳转 \"\"：设置为空时上面所有允许全部禁止 opener 如果在项目中需要打开新标签进行跳转一般会有两种方式： HTML -> JS -> window.open('http://www.baidu.com') 这两种方式看起来没有问题，但是存在漏洞：通过这两种方式打开的页面可以使用 window.opener 来访问源页面的 window 对象。 场景：A 页面通过 或 window.open 方式，打开 B 页面。但是 B 页面存在恶意代码： window.opener.location.replace('xxx') 【此代码仅针对打开新标签有效】 此时，用户正在浏览新标签页，但是原来网站的标签页已经被导航到了其它页面。 恶意网站可以伪造一个足以欺骗用户的页面，使得进行恶意破坏。 即使在跨域状态下 opener 仍可以调用 location.replace 方法。 解决方案 通过 rel 属性进行控制： noopener：会将 window.opener 置空，从而源标签页不会进行跳转（存在浏览器兼容问题） noreferrer：兼容老浏览器/火狐。禁用 HTTP 头部 Referer 属性（后端方式）。 nofollow：SEO 权重优化，详情见 https://blog.csdn.net/qq_33981438/article/details/80909881 a标签跳转url 通过将 window.open() 返回对象的 opener 手动赋值为 null click跳转 function open(url) { var newTab = window.open(); newTab.opener = null; newTab.location = url; } CSRF / XSRF（跨站请求伪造） 你可以这么理解 CSRF 攻击：攻击者盗用了你的身份，以你的名义进行恶意请求。它能做的事情有很多包括：以你的名义发送邮件、发信息、盗取账号、购买商品、虚拟货币转账等。总结起来就是：个人隐私暴露及财产安全问题。 攻击过程： 浏览并登录信任网站（举例：淘宝） 登录成功后在浏览器产生信息存储（举例：cookie） 用户在没有登出淘宝的情况下，访问危险网站 危险网站中存在恶意代码，代码为发送一个恶意请求（举例：购买商品/余额转账） 携带刚刚在浏览器产生的信息进行恶意请求 淘宝验证请求为合法请求（区分不出是否是该用户发送） 达到了恶意目标 防御措施（推荐添加 token / HTTP 头自定义属性） 涉及到数据修改操作严格使用 post 请求而不是 get 请求 HTTP 协议中使用 Referer 属性来确定请求来源进行过滤（禁止外域） 请求地址添加 token ，使黑客无法伪造用户请求 HTTP 头自定义属性验证（类似上一条） 显示验证方式：添加验证码、密码等 XSS/CSS（跨站脚本攻击） XSS 又叫 CSS（Cross Site Script），跨站脚本攻击：攻击者在目标网站植入恶意脚本（js / html），用户在浏览器上运行时可以获取用户敏感信息（cookie / session）、修改 web 页面以欺骗用户、与其他漏洞相结合形成蠕虫等。简单点来说，就是攻击者想尽一切办法*将可以执行的代码注入到网页中。 XSS 可以分为多种类型，但是总体上分为两类：持久型和非持久型。 持久型也就是攻击的代码被服务端写入进数据库中，从而导致每个访问的用户都会受到攻击。 举个例子，对于评论功能来说，就得防范持久型 XSS 攻击，因为我可以在评论中输入以下内容： 这种情况如果前后端没有做好防御的话，这段评论就会被存储到数据库中，这样每个打开该页面的用户都会被攻击到。 非持久型相比于前者危害就小的多了，一般通过修改 URL 参数的方式加入攻击代码，诱导用户访问链接从而进行攻击。 举个例子，如果页面需要从 URL 中获取某些参数作为内容的话，不经过过滤就会导致攻击代码被执行 alert(1) --> {{name}} 对于 XSS 攻击来说，通常有两种方式可以用来防御。 转义字符 首先，对于用户的输入应该是永远不信任的。最普遍的做法就是转义输入输出的内容，对于引号、尖括号、斜杠进行转义。但是对于显示富文本来说，显然不能转义所有字符，因为这样会把需要的格式也过滤掉。对于这种情况，通常采用白名单过滤的办法。 const xss = require('xss') let html = xss('XSS Demoalert(\"xss\");') console.log(html) // -> XSS Demo&lt;script&gt;alert(\"xss\");&lt;/script&gt; 以上示例使用了 js-xss 来实现，可以看到在输出中保留了 h1 标签且过滤了 script 标签。 CSP CSP 本质上就是建立白名单，开发者明确告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截是由浏览器自己实现的。我们可以通过这种方式来尽量减少 XSS 攻击。 通常可以通过两种方式来开启 CSP： 设置 HTTP Header 中的 Content-Security-Policy 设置 meta 标签的方式 以设置 HTTP Header 为例： # 只允许加载本站资源 Content-Security-Policy: default-src 'self' # 只允许加载 HTTPS 协议图片 Content-Security-Policy: img-src https://* # 允许加载任何来源框架 Content-Security-Policy: child-src 'none' 对于这种方式来说，只要开发者配置了正确的规则，那么即使网站存在漏洞，攻击者也不能执行它的攻击代码。 ClickJacking（点击劫持） 点击劫持是一种视觉欺骗的攻击手段。攻击者将需要攻击的网站通过 iframe 嵌套的方式嵌入自己的网页中，并将 iframe 设置为透明，在页面中透出一个按钮诱导用户点击。 对于这种攻击方式，推荐防御的方法有两种。 X-FRAME-OPTIONS X-FRAME-OPTIONS 是一个 HTTP 响应头，在现代浏览器有一个很好的支持。这个 HTTP 响应头，就是为了防御用 iframe 嵌套的点击劫持攻击。 该响应头有三个值可选，分别是 DENY，表示页面不允许通过 iframe 的方式展示 SAMEORIGIN，表示页面可以在相同域名下通过 iframe 的方式展示 ALLOW-FROM，表示页面可以在指定来源的 iframe 中展示 JS 防御 对于某些远古浏览器来说，并不能支持 X-FRAME-OPTIONS，那我们只有通过 JS 的方式来防御点击劫持了。 html { display: none !important; } if (self == top) { var style = document.getElementById('click-jack') document.body.removeChild(style) } else { top.location = self.location } 中间人攻击 中间人攻击是攻击方同时与服务端和客户端建立起了连接，并让对方认为连接是安全的，但是实际上整个通信过程都被攻击者控制了。攻击者不仅能获得双方的通信信息，还能修改通信信息。 通常来说不建议使用公共的 Wi-Fi，因为很可能就会发生中间人攻击的情况。如果你在通信的过程中涉及到了某些敏感信息，就完全暴露给攻击方了。 当然防御中间人攻击其实并不难，只需要增加一个安全通道来传输信息。HTTPS 就可以用来防御中间人攻击，但是并不是说使用了 HTTPS 就可以高枕无忧了，因为如果你没有完全关闭 HTTP 访问的话，攻击方可以通过某些方式将 HTTPS 降级为 HTTP 从而实现中间人攻击。 HTTPS 是如何保证安全的？ 过程⽐较复杂，我们得先理解两个概念 对称加密：即通信的双⽅都使⽤同⼀个秘钥进⾏加解密，⽐如特务接头的暗号，就属于对称加密。 对称加密虽然很简单性能也好，但是⽆法解决⾸次把秘钥发给对⽅的问题，很容易被⿊客拦截秘钥。 ⾮对称加密： 私钥 + 公钥= 密钥对 即⽤私钥加密的数据,只有对应的公钥才能解密,⽤公钥加密的数据,只有对应的私钥才能解密 因为通信双⽅的⼿⾥都有⼀套⾃⼰的密钥对,通信之前双⽅会先把⾃⼰的公钥都先发给对⽅ 然后对⽅再拿着这个公钥来加密数据响应给对⽅,等到到了对⽅那⾥,对⽅再⽤⾃⼰的私钥进⾏解密 ⾮对称加密虽然安全性更⾼，但是带来的问题就是速度很慢，影响性能。 解决⽅案： 那么结合两种加密⽅式，将对称加密的密钥使⽤⾮对称加密的公钥进⾏加密，然后发送出去，接收⽅使⽤私钥进⾏解密 得到对称加密的密钥，然后双⽅可以使⽤对称加密来进⾏沟通。 此时⼜带来⼀个问题，中间⼈问题： 如果此时在客户端和服务器之间存在⼀个中间⼈,这个中间⼈只需要把原本双⽅通信互发的公钥,换成⾃⼰的公钥,这样中 间⼈就可以轻松解密通信双⽅所发送的所有数据。 所以这个时候需要⼀个安全的第三⽅颁发证书（CA），证明身份的身份，防⽌被中间⼈攻击。 证书中包括：签发者、证书⽤途、使⽤者公钥、使⽤者私钥、使⽤者的HASH算法、证书到期时间等 但是问题来了，如果中间⼈篡改了证书，那么身份证明是不是就⽆效了？这个证明就⽩买了，这个时候需要⼀个新的技 术，数字签名。 数字签名就是⽤ CA ⾃带的 HASH 算法对证书的内容进⾏ HASH 得到⼀个摘要，再⽤ CA 的私钥加密，最终组成数字签 名。 当别⼈把他的证书发过来的时候,我再⽤同样的 Hash 算法,再次⽣成消息摘要，然后⽤ CA 的公钥对数字签名解密,得到 CA 创建的消息摘要,两者⼀⽐,就知道中间有没有被⼈篡改了。 这个时候就能最⼤程度保证通信的安全了。 CDN 劫持 出于性能考虑，前端应用通常会把一些静态资源存放到 CDN（Content Delivery Networks）上面，例如 js 脚本和 style 文件。这么做可以显著提高前端应用的访问速度，但与此同时却也隐含了一个新的安全风险。 如果攻击者劫持了 CDN，或者对 CDN 中的资源进行了污染，攻击者可以肆意篡改我们的前端页面，对用户实施攻击。 现在的 CDN 以支持 SRI 为荣，script 和 link 标签有了新的属性 integrity，这个属性是为了防止校验资源完整性来判断是否被篡改。它通过验证获取文件的哈希值是否和你提供的哈希值一样来判断资源是否被篡改。 使用 SRI 需要两个条件：一是要保证资源同域或开启跨域，二是在中提供签名以供校验。 Copyright © TeamSecret 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-09-30 11:37:55 "},"browser/performance/":{"url":"browser/performance/","title":"性能优化","keywords":"","body":"性能优化 节流和防抖 节流 考虑一个场景，滚动事件中会发起网络请求，但是我们并不希望用户在滚动过程中一直发起请求，而是隔一段时间发起一次，对于这种情况我们就可以使用节流函数 function throttle (fn, delay = 300) { let timer return function () { const args = arguments if (timer) { return } timer = setTimeout(() => { fn.apply(this, args) timer = null }, delay) } } 防抖 考虑一个场景，有一个按钮点击会触发网络请求，但是我们并不希望每次点击都发起网络请求，而是当用户点击按钮一段时间后没有再次点击的情况才去发起网络请求，对于这种情况我们就可以使用防抖。 function debounce (fn, delay) { let timer return function () { const args = arguments if (timer) { clearTimeout(timer) } timer = setTimeout(() => { fn.apply(this, args) }, delay) } } 图片优化 图片延迟加载 在页面中，先不给图片设置路径，只有当图片出现在浏览器的可视区域时，才去加载真正的图片，这就是延迟加载。 首先可以将图片这样设置，在页面不可见时图片不会加载： 等页面可见时，使用 JS 加载图片： const img = document.querySelector('img') img.src = img.dataset.src 基于 IntersectionObserver的完整代码：(关于 IntersectionObserver 请看 MDN 文档) ... // 创建配置对象 const config = { rootMargin: '0px 0px 50px 0px', // 根(root)元素的外边距。类似于 CSS 中的 margin 属性 threshold: 0 // target 元素和 root 元素相交程度达到该值的时候 IntersectionObserver 注册的回调函数将会被执行。 }; // 向 IntersectionObserver 实例注册配置对象 const observer = new IntersectionObserver(function(entries, self) { // 迭代 entries.forEach(entry => { // 只处理相交的图像 // 如果 isIntersecting 为真，target 元素的至少已经达到 thresholds 属性值当中规定的其中一个阈值 // 如果为假，则 target 元素不在给定的阈值范围内可见。 if (entry.isIntersecting) { // 将 target 的 data-src 属性值赋值给 src entry.target.src = entry.target.dataset.src // 图片加载完成，停止监听 self.unobserve(entry.target); } }); }, config); const images = document.querySelectorAll('[data-src]'); images.forEach(img => { observer.observe(img); }); 效果预览： 响应式图片 尤其对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。 可以使用用 CDN 加载图片，计算出适配屏幕的宽度，然后去请求相应裁剪好的图片。 通过 picture 实现 通过 @media 实现 @media (min-width: 769px) { .bg { background-image: url(bg1080.jpg); } } @media (max-width: 768px) { .bg { background-image: url(bg768.jpg); } } 降低图片质量 例如 JPG 格式的图片，100% 的质量和 90% 质量的通常看不出来区别，尤其是用来当背景图的时候。 通过 webpack 插件 image-webpack-loader 压缩图片。 npm i -D image-webpack-loader 配置： { test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/, use:[ { loader: 'url-loader', options: { limit: 10000, /* 图片小于 1000 字节限制时会自动转成 base64 码引用 */ name: utils.assetsPath('img/[name].[hash:7].[ext]') } }, /*对图片进行压缩*/ { loader: 'image-webpack-loader', options: { bypassOnDebug: true, } } ] } 其它关于图片的优化建议 尽可能利用 CSS3 效果代替图片 使用 webp 格式的图片 小图使用 base64 格式 图标这类图片，完全可以使用 SVG 代替 将多个图标文件整合到一张图片中（雪碧图） 字体图标 iconfont 代替图片图标 DNS 预解析 DNS 解析也是需要时间的，可以通过预解析的方式来预先获得域名所对应的 IP。 现代浏览器都支持 DNS 的预解析，学名：DNS Prefetching。用法也很简单，就是在html代码里加入这样的 link 标签 chrome 会自动把当前页面的所有带 href 的 link 的 dns 都 prefetch 一遍。 需要手动添加 link 标签的场景是：你预计用户在后面的访问中需要用到当前页面的所有链接都不包含的域名。 减少 HTTP 请求 一个完整的 HTTP 请求需要经历 DNS 查找，TCP 握手，浏览器发出 HTTP 请求，服务器接收请求，服务器处理请求并发回响应，浏览器接收响应等过程。减少请求次数，对提升性能无疑是有帮助的。 使用 HTTP 2 HTTP2 相比 HTTP1.1 有如下几个优点： 解析速度 服务器解析 HTTP1.1 的请求时，必须不断地读入字节，直到遇到分隔符 CRLF 为止。而解析 HTTP2 的请求就不用这么麻烦，因为 HTTP2 是基于帧的协议，每个帧都有表示帧长度的字段。 多路复用 HTTP1.1 如果要同时发起多个请求，就得建立多个 TCP 连接，因为一个 TCP 连接同时只能处理一个 HTTP1.1 的请求。 在 HTTP2 上，多个请求可以共用一个 TCP 连接，这称为多路复用。同一个请求和响应用一个流来表示，并有唯一的流 ID 来标识。多个请求和响应在 TCP 连接中可以乱序发送，到达目的地后再通过流 ID 重新组建。 首部压缩 HTTP2 提供了首部压缩功能。 例如有如下两个请求： :authority: github.com :method: GET :path: /za-js-sdk@2.16.0/dist/zap.js :scheme: https accept: */* accept-encoding: gzip, deflate, br accept-language: zh-CN,zh;q=0.9 cache-control: no-cache pragma: no-cache referer: https://www.github.com/ sec-fetch-dest: script sec-fetch-mode: no-cors sec-fetch-site: cross-site user-agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.122 Safari/537.36 :authority: github.com :method: GET :path: /linksubmit/push.js :scheme: https accept: */* accept-encoding: gzip, deflate, br accept-language: zh-CN,zh;q=0.9 cache-control: no-cache pragma: no-cache referer: https://www.github.com/ sec-fetch-dest: script sec-fetch-mode: no-cors sec-fetch-site: cross-site user-agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.122 Safari/537.36 从上面两个请求可以看出来，有很多数据都是重复的。如果可以把相同的首部存储起来，仅发送它们之间不同的部分，就可以节省不少的流量，加快请求的时间。 HTTP/2 在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键－值对，对于相同的数据，不再通过每次请求和响应发送。 假设客户端按顺序发送如下请求首部： 索引 首部名称 值 62 Header1 foo 63 Header2 bar 64 Header3 bat 如果服务器收到了请求，它会照样创建一张表。 当客户端发送下一个请求的时候，如果首部相同，它可以直接发送这样的首部块： 62 63 64 服务器会查找先前建立的表格，并把这些数字还原成索引对应的完整首部。 优先级 HTTP2 可以对比较紧急的请求设置一个较高的优先级，服务器在收到这样的请求后，可以优先处理。 流量控制 由于一个 TCP 连接流量带宽（根据客户端到服务器的网络带宽而定）是固定的，当有多个请求并发时，一个请求占的流量多，另一个请求占的流量就会少。流量控制可以对不同的流的流量进行精确控制。 服务器推送 HTTP2 新增的一个强大的新功能，就是服务器可以对一个客户端请求发送多个响应。换句话说，除了对最初请求的响应外，服务器还可以额外向客户端推送资源，而无需客户端明确地请求。 例如当浏览器请求一个网站时，除了返回 HTML 页面外，服务器还可以根据 HTML 页面中的资源的 URL，来提前推送资源。 使用服务端渲染 客户端渲染: 获取 HTML 文件，根据需要下载 JavaScript 文件，运行文件，生成 DOM，再渲染。 服务端渲染：服务端返回 HTML 文件，客户端只需解析 HTML。 优点：首屏渲染快，SEO 好。 缺点：配置麻烦，增加了服务器的计算压力。 下面我用 Vue SSR 做示例，简单的描述一下 SSR 过程。 客户端渲染过程 访问客户端渲染的网站。 服务器返回一个包含了引入资源语句和 的 HTML 文件。 客户端通过 HTTP 向服务器请求资源，当必要的资源都加载完毕后，执行 new Vue() 开始实例化并渲染页面。 服务端渲染过程 访问服务端渲染的网站。 服务器会查看当前路由组件需要哪些资源文件，然后将这些文件的内容填充到 HTML 文件。如果有 ajax 请求，就会执行它进行数据预取并填充到 HTML 文件里，最后返回这个 HTML 页面。 当客户端接收到这个 HTML 页面时，可以马上就开始渲染页面。与此同时，页面也会加载资源，当必要的资源都加载完毕后，开始执行 new Vue() 开始实例化并接管页面。 从上述两个过程中可以看出，区别就在于第二步。客户端渲染的网站会直接返回 HTML 文件，而服务端渲染的网站则会渲染完页面再返回这个 HTML 文件。 这样做的好处就是更快的内容到达时间 (time-to-content)。 手把手教你搭建 Vue 服务端渲染项目 静态资源使用 CDN 内容分发网络（CDN）是一组分布在多个不同地理位置的 Web 服务器。我们都知道，当服务器离用户越远时，延迟越高。CDN 就是为了解决这一问题，在多个位置部署服务器，让用户离服务器更近，从而缩短请求时间。 CDN 原理 当用户访问一个网站时，如果没有 CDN，过程是这样的： 浏览器要将域名解析为 IP 地址，所以需要向本地 DNS 发出请求。 本地 DNS 依次向根服务器、顶级域名服务器、权限服务器发出请求，得到网站服务器的 IP 地址。 本地 DNS 将 IP 地址发回给浏览器，浏览器向网站服务器 IP 地址发出请求并得到资源。 如果用户访问的网站部署了 CDN，过程是这样的： 浏览器要将域名解析为 IP 地址，所以需要向本地 DNS 发出请求。 本地 DNS 依次向根服务器、顶级域名服务器、权限服务器发出请求，得到全局负载均衡系统（GSLB）的 IP 地址。 本地 DNS 再向 GSLB 发出请求，GSLB 的主要功能是根据本地 DNS 的 IP 地址判断用户的位置，筛选出距离用户较近的本地负载均衡系统（SLB），并将该 SLB 的 IP 地址作为结果返回给本地 DNS。 本地 DNS 将 SLB 的 IP 地址发回给浏览器，浏览器向 SLB 发出请求。 SLB 根据浏览器请求的资源和地址，选出最优的缓存服务器发回给浏览器。 浏览器再根据 SLB 发回的地址重定向到缓存服务器。 如果缓存服务器有浏览器需要的资源，就将资源发回给浏览器。如果没有，就向源服务器请求资源，再发给浏览器并缓存在本地。 将 CSS 放在文件头部，JavaScript 文件放在底部 所有放在 head 标签里的 CSS 和 JS 文件都会堵塞渲染。如果这些 CSS 和 JS 需要加载和解析很久的话，那么页面就空白了。所以 JS 文件要放在底部，等 HTML 解析完了再加载 JS 文件。 那为什么 CSS 文件还要放在头部呢？ 因为先加载 HTML 再加载 CSS，会让用户第一时间看到的页面是没有样式的、“丑陋”的，为了避免这种情况发生，就要将 CSS 文件放在头部了。 压缩文件 除了压缩 JS/CSS/HTML 外，还可以开启 gzip 压缩。 服务端开启 gzip 配置即可，前端也可以先生成 gz 压缩文件上传到服务器，这样可以减轻服务器压力。 比如，现在客户端请求一个 test.js 文件，服务端开启了 gzip 压缩的话，就会先去查找是否存在 test.js.gz 文件，如果有，就直接返回，否则由服务器压缩生成一个 gz 文件再返回给客户端。 以 Vue 为例，可以使用 compression-webpack-plugin 插件开启 gzip 压缩： npm install compression-webpack-plugin --save-dev const CompressionPlugin = require('compression-webpack-plugin') module.exports = { configureWebpack: { plugins: [ new CompressionPlugin({ algorithm: 'gzip', test: /\\.(js|css|json|txt|html|ico|svg)(\\?.*)?$/i, threshold: 5120, //只处理比这个值大的资源。按字节计算 minRatio: 0.8, // 只有压缩率比这个值小的资源才会被处理 deleteOriginalAssets: false // 是否删除原文件 }) ] } } 善用缓存，不重复加载相同的资源 浏览器缓存机制 减少重绘和回流 重绘（Repaint）和回流（Reflow） 使用事件代理 事件代理 Copyright © TeamSecret 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-10-22 12:06:08 "},"frame/mvvm/":{"url":"frame/mvvm/","title":"MVC、MVP 和 MVVM","keywords":"","body":"MVC、MVP 和 MVVM 什么是 MVVM？比之 MVC 有什么区别？什么又是 MVP ？ MVC、MVP 和 MVVM 是三种常见的软件架构设计模式，主要通过分离关注点的方式来组织代码结构，优化我们的开发效率。 MVC MVC 通过分离 Model、View 和 Controller 的方式来组织代码结构。 其中 View 负责页面的显示逻辑。 Model 负责存储页面的业务数据，以及对相应数据的操作。 并且 View 和 Model 应用了观察者模式，当 Model 层发生改变的时候它会通知有关 View 层更新页面。 Controller 层是 View 层和 Model 层的纽带，它主要负责用户与应用的响应操作，当用户与页面产生交互的时候，Controller 中的事件触发器就开始工作了，通过调用 Model 层，来完成对 Model 的修改，然后 Model 层再去通知 View 层更新。 MVP MVP 模式与 MVC 唯一不同的在于 Presenter 和 Controller。 在 MVC 模式中我们使用观察者模式，来实现当 Model 层数据发生变化的时候，通知 View 层的更新。这样 View 层和Model 层耦在一起，当项目逻辑变得复杂的时候，可能会造成代码的混乱，并且可能会对代码的复用性造成一些问题。 MVP 的模式通过使用 Presenter 来实现对 View 层和 Model 层的解耦。 MVC 中的 Controller 只道 Model 的接口，因此它没有办法控制 View 层的更新，MVP 模式中，View 层的接口暴露给了 Presenter， 因此我们可以在 Presenter 中将 Model 的变化和 View 的变化绑定在一起，以此来实现 View 和 Model 的同步更新。这样就实现了对 View 和 Model 的解耦，Presenter 还包含了其他的响应逻辑。 MVVM MVVM 模式中的 VM，指的是 ViewModel，它和 MVP 的思想其实是相同的，不过它通过双向的数据绑定，将 View 和 Model 的同步更新给自动化了。当 Model 发生变化的时候，ViewModel 就会自动更新；ViewModel 变化了，View 也会更新。这样就将 Presenter 中的工作给自动化了。 为什么说 Vue 和 React 都不是 MVVM 框架？ Vue 是一个提供了 MVVM 风格的双向数据绑定的框架。它的核心是 MVVM 中的 VM，也就是 ViewModel。 在 Vue 中，Model 和 VM，VM 和 和 View 之间都是双向数据绑定，实现方式是数据劫持。 但是在 Vue 中，哪一部分是 VM，哪一部分是 M，其实不太好区分。如果 Vue 的一个实例是 VM，那么 model 是什么？如果 data 是 model，先经过实例中的逻辑改变 data，然后 view 产生变化又不符合 MVVM。或者说 VM 是 Vue 框架实现数据响应的源码，实例中的逻辑是 model 层的逻辑，用于改变 model 。所以，个人认为 Vue 只能说是有 MVVM 风格的框架，不能说是一个 MVVM 框架。 react，单向数据流。本身只是一个函数 ui => render (data) ,官方就这么简单一个公式。加上状态管理等，可以做 MVVM 风格的开发。 不管是 MVC 还是 MVVM ，具体到实际框架，组成成分之间都不会泾渭分明，几种组成成分之间常常有难以划分的模糊地带。如果忽略划分细节从整体来看，Vue 参考但没有完全遵循 MVVM，React 只是一个 View 层。 Copyright © TeamSecret 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-10-02 17:27:27 "},"frame/VirtualDOM/":{"url":"frame/VirtualDOM/","title":"Virtual DOM","keywords":"","body":"Virtual DOM 什么是 Virtual DOM ？ 大家都知道操作 DOM 是很慢的，为什么操作 DOM 慢？ 那么相较于 DOM 来说，操作 JS 对象会快很多，并且我们也可以通过 JS 来模拟 DOM const ul = { tag: 'ul', props: { class: 'list' }, children: { tag: 'li', children: '1' } } 上述代码对应的 DOM 就是 1 那么既然 DOM 可以通过 JS 对象来模拟，反之也可以通过 JS 对象来渲染出对应的 DOM。当然了，通过 JS 来模拟 DOM 并且渲染对应的 DOM 只是第一步，难点在于如何判断新旧两个 JS 对象的最小差异并且实现局部更新 DOM。 首先 DOM 是一个多叉树的结构，如果需要完整的对比两颗树的差异，那么需要的时间复杂度会是 O(n ^ 3)，这个复杂度肯定是不能接受的。于是 React 团队优化了算法，实现了 O(n) 的复杂度来对比差异。 实现 O(n) 复杂度的关键就是只对比同层的节点，而不是跨层对比，这也是考虑到在实际业务中很少会去跨层的移动 DOM 元素。 所以判断差异的算法就分为了两步 首先从上至下，从左往右遍历对象，也就是树的深度遍历，这一步中会给每个节点添加索引，便于最后渲染差异 一旦节点有子元素，就去判断子元素是否有不同 在第一步算法中我们需要判断新旧节点的 tagName 是否相同，如果不相同的话就代表节点被替换了。如果没有更改 tagName 的话，就需要判断是否有子元素，有的话就进行第二步算法。 在实际的算法中，我们如何去识别改动的是哪个节点呢？这就引入了 key 这个属性，想必大家在 Vue 或者 React 的列表中都用过这个属性。这个属性是用来给每一个节点打标志的，用于判断是否是同一个节点。 diff 算法 当状态中的数据发生变化时，Vue/React 会根据新数据生成新的虚拟 DOM，随后进行虚拟 DOM 与 旧虚拟 DOM 的 diff 比较，规则如下： 旧虚拟 DOM 中找到了与新虚拟 DOM 相同的 key: 1). 若虚拟 DOM 中内容没变，直接使用之前的真实 DOM 2). 若虚拟 DOM 中的内容变了，则生成新的真实 DOM，随后替换掉页面中之前的真实 DOM 旧虚拟 DOM 中未找到与新虚拟 DOM 相同的 key，则根据数据创建新的真实 DOM，随后渲染到页面 用数组的 index 作为 key可能会引发什么问题？ 如果对数据进行逆序添加、删除等破坏顺序的操作，会产生没有必要的真实 DOM 更新，导致效率低下。 如果页面结构中还包含有输入类的 DOM，则会产生错误的 DOM 更新。 Vue 和 React 中 diff 算法的区别 相同点 都是两组虚拟 dom 的对比（react16.8 之后是 fiber 与虚拟 dom 的对比） 只对同级节点进行对比，简化了算法复杂度 都用 key 做为唯一标识，进行查找，只有 key 和标签类型相同时才会复用老节点 遍历前都会根据老的节点构建一个 map，方便根据 key 快速查找 不同点 react 在 diff 遍历的时候，只对需要修改的节点进行了记录，形成 effect list，最后才会根据 effect list 进行真实 dom 的修改，修改时先删除，然后更新与移动，最后插入 vue 在遍历的时候就用真实 dom insertBefore 方法，修改了真实 dom ，最后做的删除操作 react 采用单指针从左向右进行遍历 vue 采用双指针，从两头向中间进行遍历 react 的虚拟 diff 比较简单，vue 中做了一些优化处理，相对复杂，但效率更高 Copyright © TeamSecret 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-10-02 21:17:17 "},"frame/router/":{"url":"frame/router/","title":"路由","keywords":"","body":"路由 前端路由实现起来其实很简单，本质就是监听 URL 的变化，然后匹配路由规则，显示相应的页面，并且无须刷新页面。目前前端使用的路由就只有两种实现方式 Hash 模式 History 模式 Hash 模式 www.test.com/#/ 就是 Hash URL，当 # 后面的哈希值发生变化时，可以通过 hashchange 事件来监听到 URL 的变化，从而进行跳转页面，并且无论哈希值如何变化，服务端接收到的 URL 请求永远是 www.test.com 。 window.addEventListener('hashchange', () => { // ... 具体逻辑 }) Hash 模式相对来说更简单，并且兼容性也更好。 History 模式 History 模式是 HTML5 新推出的功能，主要使用 history.pushState 和 history.replaceState 改变 URL。 通过 History 模式改变 URL 同样不会引起页面的刷新，只会更新浏览器的历史记录。 // 新增历史记录 history.pushState(stateObject, title, URL) // 替换当前历史记录 history.replaceState(stateObject, title, URL) 当用户做出浏览器动作时，比如点击后退按钮时会触发 popState 事件 window.addEventListener('popstate', e => { // e.state 就是 pushState(stateObject) 中的 stateObject console.log(e.state) }) 两种模式的对比 Hash 模式只可以更改 # 后面的内容，History 模式可以通过 API 设置任意的同源 URL History 模式可以通过 API 添加任意类型的数据到历史记录中，Hash 模式只能更改哈希值，也就是字符串 Hash 模式无需后端配置，并且兼容性好。History 模式在用户手动输入地址或者刷新页面的时候会发起 URL 请求，后端需要配置 index.html 页面用于匹配不到静态资源的时候 Copyright © TeamSecret 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-10-04 11:18:14 "},"frame/vue/":{"url":"frame/vue/","title":"Vue","keywords":"","body":"Vue 生命周期 在 beforeCreate 钩子函数调用的时候，是获取不到 props 或者 data 中的数据的，因为这些数据的初始化都在 initState 中。 然后会执行 created 钩子函数，在这一步的时候已经可以访问到之前不能访问到的数据，但是这时候组件还没被挂载，所以是看不到的。 接下来会先执行 beforeMount 钩子函数，开始创建 VDOM，最后执行 mounted 钩子，并将 VDOM 渲染为真实 DOM 并且渲染数据。组件中如果有子组件的话，会递归挂载子组件，只有当所有子组件全部挂载完毕，才会执行根组件的挂载钩子。 接下来是数据更新时会调用的钩子函数 beforeUpdate 和 updated，这两个钩子函数没什么好说的，就是分别在数据更新前和更新后会调用。 另外还有 keep-alive 独有的生命周期，分别为 activated 和 deactivated 。用 keep-alive 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 deactivated 钩子函数，命中缓存渲染后会执行 actived 钩子函数。 最后就是销毁组件的钩子函数 beforeDestroy 和 destroyed。前者适合移除事件、定时器等等，否则可能会引起内存泄露的问题。然后进行一系列的销毁操作，如果有子组件的话，也会递归销毁子组件，所有子组件都销毁完毕后才会执行根组件的 destroyed 钩子函数。 响应式原理 首先可以看看官方文档给出的解释。 总结一下: 任何一个 Vue Component 都有一个与之对应的 Watcher 实例。 Vue 的 data 上的属性会被添加 getter 和 setter 属性。 当 Vue Component render 函数被执行的时候, data 上会被 触碰(touch), 即被读, getter 方法会被调用, 此时 Vue 会去记录此 Vue component 所依赖的所有 data。(这一过程被称为依赖收集) data 被改动时（主要是用户操作）, 即被写, setter 方法会被调用, 此时 Vue 会去通知所有依赖于此 data 的组件去调用他们的 render 函数进行更新。 NextTick 原理分析 nextTick 可以让我们在下次 DOM 更新循环结束之后执行延迟回调，用于获得更新后的 DOM。 在 Vue 2.4 之前都是使用的 microtasks，但是 microtasks 的优先级过高，在某些情况下可能会出现比事件冒泡更快的情况，但如果都使用 macrotasks 又可能会出现渲染的性能问题。所以在新版本中，会默认使用 microtasks，但在特殊情况下会使用 macrotasks，比如 v-on。 对于实现 macrotasks ，会先判断是否能使用 setImmediate ，不能的话降级为 MessageChannel ，以上都不行的话就使用 setTimeout 而对于 microtask 的实现，则检测浏览器是否原生支持 Promise，不支持的话直接指向 macrotask 的实现。 组件通信 组件通信一般分为以下几种情况： 父子组件通信 兄弟组件通信 跨多层级组件通信 任意组件 父子通信 父组件通过 props 传递数据给子组件，子组件通过 emit 发送事件传递数据给父组件，这两种方式是最常用的父子通信实现办法。 这种父子通信方式也就是典型的单向数据流，父组件通过 props 传递数据，子组件不能直接修改 props， 而是必须通过发送事件的方式告知父组件修改数据。 另外这两种方式还可以使用语法糖 v-model 来直接实现，因为 v-model 默认会解析成名为 value 的 prop 和名为 input 的事件。这种语法糖的方式是典型的双向绑定，常用于 UI 控件上，但是究其根本，还是通过事件的方法让父组件修改数据。 当然我们还可以通过访问 $parent 或者 $children 对象来访问组件实例中的方法和数据。 另外如果使用 Vue 2.3 及以上版本的话还可以使用 $listeners 和 .sync 这两个属性。 $listeners 属性会将父组件中的 (不含 .native 修饰器的) v-on 事件监听器传递给子组件，子组件可以通过访问 $listeners 来自定义监听器。 .sync 属性是个语法糖，可以很简单的实现子组件与父组件通信 value = v\"> this.$emit('update:value', 1) 兄弟组件通信 对于这种情况可以通过查找父组件中的子组件实现，也就是 this.$parent.$children，在 $children 中可以通过组件 name 查询到需要的组件实例，然后进行通信。 跨多层次组件通信 对于这种情况可以使用 Vue 2.2 新增的 API provide / inject，虽然文档中不推荐直接使用在业务中，但是如果用得好的话还是很有用的。 假设有父组件 A，然后有一个跨多层级的子组件 B // 父组件 A export default { provide: { data: 1 } } // 子组件 B export default { inject: ['data'], mounted() { // 无论跨几层都能获得父组件的 data 属性 console.log(this.data) // => 1 } } 任意组件 这种方式可以通过 Vuex 或者 Event Bus 解决，另外如果你不怕麻烦的话，可以使用这种方式解决上述所有的通信情况 extend 能做什么 这个 API 很少用到，作用是扩展组件生成一个构造器，通常会与 $mount 一起使用。 // 创建组件构造器 let Component = Vue.extend({ template: 'test' }) // 挂载到 #app 上 new Component().$mount('#app') // 除了上面的方式，还可以用来扩展已有的组件 let SuperComponent = Vue.extend(Component) new SuperComponent({ created() { console.log(1) } }) new SuperComponent().$mount('#app') mixin 和 mixins 区别 mixin 用于全局混入，会影响到每个组件实例，通常插件都是这样做初始化的。 Vue.mixin({ beforeCreate() { // ...逻辑 // 这种方式会影响到每个组件的 beforeCreate 钩子函数 } }) 虽然文档不建议我们在应用中直接使用 mixin，但是如果不滥用的话也是很有帮助的，比如可以全局混入封装好的 ajax 或者一些工具函数等等。 mixins 应该是我们最常使用的扩展组件的方式了。如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过 mixins 混入代码，比如上拉下拉加载数据这种逻辑等等。 另外需要注意的是 mixins 混入的钩子函数会先于组件内的钩子函数执行，并且在遇到同名选项的时候也会有选择性的进行合并，具体可以阅读文档。 computed 和 watch 区别 computed 是计算属性，依赖其他属性计算值，并且 computed 的值有缓存，只有当计算值变化才会返回内容。 watch 监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。 所以一般来说需要依赖别的属性来动态获得值的时候可以使用 computed，对于监听到值的变化需要做一些复杂业务逻辑的情况可以使用 watch。 keep-alive 组件有什么作用 如果你需要在组件切换的时候，保存一些组件的状态防止多次渲染，就可以使用 keep-alive 组件包裹需要保存的组件。 对于 keep-alive 组件来说，它拥有两个独有的生命周期钩子函数，分别为 activated 和 deactivated 。用 keep-alive 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 deactivated 钩子函数，命中缓存渲染后会执行 actived 钩子函数。 v-show 与 v-if 区别 v-show 只是在 display: none 和 原始的 display 之间切换。无论初始条件是什么都会被渲染出来，后面只需要切换 CSS，DOM 还是一直保留着的。所以总的来说 v-show 在初始渲染时有更高的开销，但是切换开销很小，更适合于频繁切换的场景。 v-if 的话就得说到 Vue 底层的编译了。当属性初始为 false 时，组件就不会被渲染，直到条件为 true，并且切换条件时会触发销毁/挂载组件，所以总的来说在切换时开销更高，更适合不经常切换的场景。 并且基于 v-if 的这种惰性渲染机制，可以在必要的时候才去渲染组件，减少整个页面的初始渲染开销 组件中 data 什么时候可以使用对象 组件复用时所有组件实例都会共享 data，如果 data 是对象的话，就会造成一个组件修改 data 以后会影响到其他所有组件，所以需要将 data 写成函数，每次用到就调用一次函数获得新的数据。 当我们使用 new Vue() 的方式的时候，无论我们将 data 设置为对象还是函数都是可以的，因为 new Vue() 的方式是生成一个根组件，该组件不会复用，也就不存在共享 data 的情况了。 Copyright © TeamSecret 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-10-04 16:20:05 "},"net/udp/":{"url":"net/udp/","title":"UDP","keywords":"","body":"UDP 网络协议是每个前端工程师都必须要掌握的知识，我们将先来学习传输层中的两个协议：UDP 以及 TCP。对于大部分工程师来说最常用的协议也就是这两个了，并且面试中经常会提问的也是关于这两个协议的区别。 首先 UDP 协议是面向无连接的，也就是说不需要在正式传递数据之前先连接起双方。然后 UDP 协议只是数据报文的搬运工，不保证有序且不丢失的传递到对端，并且 UDP 协议也没有任何控制流量的算法，总的来说 UDP 相较于 TCP 更加的轻便。 面向无连接 首先 UDP 是不需要和 TCP 一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。 并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。 具体来说就是： 在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了 在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作 不可靠性 首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。 并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。 再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。 高效 虽然 UDP 协议不是那么的可靠，但是正是因为它不是那么的可靠，所以也就没有 TCP 那么复杂了，需要保证数据不丢失且有序到达。 因此 UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很高效的。 UDP 头部包含了以下几个数据 两个十六位的端口号，分别为源端口（可选字段）和目标端口 整个数据报文的长度 整个数据报文的检验和（IPv4 可选 字段），该字段用于发现头部信息和数据中的错误 传输方式 UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。 适合使用的场景 UDP 虽然对比 TCP 有很多缺点，但是正是因为这些缺点造就了它高效的特性，在很多实时性要求高的地方都可以看到 UDP 的身影。 Copyright © TeamSecret 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-10-05 11:28:08 "},"net/tcp/":{"url":"net/tcp/","title":"TCP","keywords":"","body":"TCP TCP 基本是和 UDP 反着来，建立连接断开连接都需要先需要进行握手。在传输数据的过程中，通过各种算法保证数据的可靠性，当然带来的问题就是相比 UDP 来说不那么的高效。 头部 TCP 头部比 UDP 头部复杂的多。 对于 TCP 头部来说，以下几个字段是很重要的 Sequence number，这个序号保证了 TCP 传输的报文都是有序的，对端可以通过序号顺序的拼接报文 Acknowledgement Number，这个序号表示数据接收端期望接收的下一个字节的编号是多少，同时也表示上一个序号的数据已经收到 Window Size，窗口大小，表示还能接收多少字节的数据，用于流量控制 标识符 URG=1：该字段为一表示本数据报的数据部分包含紧急信息，是一个高优先级数据报文，此时紧急指针有效。紧急数据一定位于当前数据包数据部分的最前面，紧急指针标明了紧急数据的尾部。 ACK=1：该字段为一表示确认号字段有效。此外，TCP 还规定在连接建立后传送的所有报文段都必须把 ACK 置为一。 PSH=1：该字段为一表示接收端应该立即将数据 push 给应用层，而不是等到缓冲区满后再提交。 RST=1：该字段为一表示当前 TCP 连接出现严重问题，可能需要重新建立 TCP 连接，也可以用于拒绝非法的报文段和拒绝连接请求。 SYN=1：当SYN=1，ACK=0时，表示当前报文段是一个连接请求报文。当SYN=1，ACK=1时，表示当前报文段是一个同意建立连接的应答报文。 FIN=1：该字段为一表示此报文段是一个释放连接的请求报文。 状态机 TCP 的状态机是很复杂的，并且与建立断开连接时的握手息息相关。 建立连接三次握手 首先假设主动发起请求的一端称为客户端，被动连接的一端称为服务端。不管是客户端还是服务端，TCP 连接建立完后都能发送和接收数据，所以 TCP 是一个全双工的协议。 起初，两端都为 CLOSED 状态。在通信开始前，双方都会创建 TCB。 服务器创建完 TCB 后便进入 LISTEN 状态，此时开始等待客户端发送数据。 第一次握手 客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态。 第二次握手 服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。 第三次握手 当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。 PS：第三次握手中可以包含数据，通过快速打开（TFO）技术就可以实现这一功能。其实只要涉及到握手的协议，都可以使用类似 TFO 的方式，客户端和服务端存储相同的 cookie，下次握手时发出 cookie 达到减少 RTT 的目的。 为什么 TCP 建立连接需要三次握手，明明两次就可以建立起连接 这是为了防止出现失效的连接请求报文段被服务端接收的情况，从而产生错误。 可以想象如下场景。客户端发送了一个连接请求 A，但是因为网络原因造成了超时，这时 TCP 会启动超时重传的机制再次发送一个连接请求 B。此时请求顺利到达服务端，服务端应答完就建立了请求，然后接收数据后释放了连接。 假设这时候连接请求 A 在两端关闭后终于抵达了服务端，那么此时服务端会认为客户端又需要建立 TCP 连接，从而应答了该请求并进入 ESTABLISHED 状态。但是客户端其实是 CLOSED 的状态，那么就会导致服务端一直等待，造成资源的浪费。 PS：在建立连接中，任意一端掉线，TCP 都会重发 SYN 包，一般会重试五次，在建立连接中可能会遇到 SYN Flood 攻击。遇到这种情况你可以选择调低重试次数或者干脆在不能处理的情况下拒绝请求。 断开链接四次握手 TCP 是全双工的，在断开连接时两端都需要发送 FIN 和 ACK。 第一次握手 若客户端 A 认为数据发送完成，则它需要向服务端 B 发送连接释放请求。 第二次握手 B 收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明 A 到 B 的连接已经释放，不再接收 A 发的数据了。但是因为 TCP 连接是双向的，所以 B 仍旧可以发送数据给 A。 第三次握手 B 如果此时还有没发完的数据会继续发送，完毕后会向 A 发送连接释放请求，然后 B 便进入 LAST-ACK 状态。 PS：通过延迟确认的技术（通常有时间限制，否则对方会误认为需要重传），可以将第二次和第三次握手合并，延迟 ACK 包的发送。 第四次握手 A 收到释放请求后，向 B 发送确认应答，此时 A 进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有 B 的重发请求的话，就进入 CLOSED 状态。当 B 收到确认应答后，也便进入 CLOSED 状态。 为什么 A 要进入 TIME-WAIT 状态，等待 2MSL 时间后才进入 CLOSED 状态？ 为了保证 B 能收到 A 的确认应答。若 A 发完确认应答后直接进入 CLOSED 状态，如果确认应答因为网络问题一直没有到达，那么会造成 B 不能正常关闭。 Copyright © TeamSecret 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-10-09 23:54:26 "},"net/http/":{"url":"net/http/","title":"HTTP 和 HTTPS","keywords":"","body":"HTTP 和 HTTPS HTTP HTTP 请求中的内容 HTTP 请求由三部分构成，分别为： 请求行 首部 实体 请求行 请求行大概长这样 GET /images/logo.gif HTTP/1.1，基本由请求方法、URL、协议版本组成，这其中值得一说的就是请求方法了。 常用的请求方法有： GET（SELECT）：从服务器取出资源（一项或多项）。 POST（CREATE）：在服务器新建一个资源。 PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。 PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。 DELETE（DELETE）：从服务器删除资源。 更多请求方法的语义描述可以阅读 文档。 Post 和 Get 的区别？ 首先先引入副作用和幂等的概念。 副作用指对服务器上的资源做改变，比如：搜索是无副作用的，注册是副作用的。 幂等指发送 M 和 N 次请求（两者不相同且都大于 1），服务器上资源的状态一致，比如注册 10 个和 11 个帐号是不幂等的，对文章进行更改 10 次和 11 次是幂等的。因为前者是多了一个账号（资源），后者只是更新同一个资源。 在规范的应用场景上说，Get 多用于无副作用，幂等的场景，例如搜索关键字。Post 多用于副作用，不幂等的场景，例如注册。 在技术上说： Get 请求能缓存，Post 不能 Post 相对 Get 安全一点点，因为Get 请求都包含在 URL 里（当然你想写到 body 里也是可以的），且会被浏览器保存历史纪录。Post 不会，但是在抓包的情况下都是一样的。 URL有长度限制，会影响 Get 请求，但是这个长度限制是浏览器规定的，不是 RFC 规定的 Post 支持更多的编码类型且不对数据类型限制 首部 首部分为请求首部和响应首部，并且部分首部两种通用。 通用首部 通用字段 作用 Cache-Control 控制缓存的行为 Connection 浏览器想要优先使用的连接类型，比如 keep-alive Date 创建报文时间 Pragma 报文指令 Via 代理服务器相关信息 Transfer-Encoding 传输编码方式 Upgrade 要求客户端升级协议 Warning 在内容中可能存在错误 请求首部 请求首部 作用 Accept 能正确接收的媒体类型 Accept-Charset 能正确接收的字符集 Accept-Encoding 能正确接收的编码格式列表 Accept-Language 能正确接收的语言列表 Expect 期待服务端的指定行为 From 请求方邮箱地址 Host 服务器的域名 If-Match 两端资源标记比较 If-Modified-Since 本地资源未修改返回 304（比较时间） If-None-Match 本地资源未修改返回 304（比较标记） User-Agent 客户端信息 Max-Forwards 限制可被代理及网关转发的次数 Proxy-Authorization 向代理服务器发送验证信息 Range 请求某个内容的一部分 Referer 表示浏览器所访问的前一个页面 TE 传输编码方式 响应首部 响应首部 作用 Accept-Ranges 是否支持某些种类的范围 Age 资源在代理缓存中存在的时间 ETag 资源标识 Location 客户端重定向到某个 URL Proxy-Authenticate 向代理服务器发送验证信息 Server 服务器名字 WWW-Authenticate 获取资源需要的验证信息 实体首部 实体首部 作用 Allow 资源的正确请求方式 Content-Encoding 内容的编码格式 Content-Language 内容使用的语言 Content-Length request body 长度 Content-Location 返回数据的备用地址 Content-MD5 Base64加密格式的内容 MD5检验值 Content-Range 内容的位置范围 Content-Type 内容的媒体类型 Expires 内容的过期时间 Last_modified 内容的最后修改时间 常见状态码 状态码表示了响应的一个状态，可以让我们清晰的了解到这一次请求是成功还是失败，如果失败的话，是什么原因导致的，当然状态码也是用于传达语义的。如果胡乱使用状态码，那么它存在的意义就没有了。 2XX 成功 200 OK，表示从客户端发来的请求在服务器端被正确处理 204 No content，表示请求成功，但响应报文不含实体的主体部分 205 Reset Content，表示请求成功，但响应报文不含实体的主体部分，但是与 204 响应不同在于要求请求方重置内容 206 Partial Content，进行范围请求 3XX 重定向 301 moved permanently，永久性重定向，表示资源已被分配了新的 URL 302 found，临时性重定向，表示资源临时被分配了新的 URL 303 see other，表示资源存在着另一个 URL，应使用 GET 方法获取资源 304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况 307 temporary redirect，临时重定向，和302含义类似，但是期望客户端保持请求方法不变向新的地址发出请求 4XX 客户端错误 400 bad request，请求报文存在语法错误 401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息 403 forbidden，表示对请求资源的访问被服务器拒绝 404 not found，表示在服务器上没有找到请求的资源 5XX 服务器错误 500 internal sever error，表示服务器端在执行请求时发生了错误 501 Not Implemented，表示服务器不支持当前请求所需要的某个功能 503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求 HTTPS 和 TLS HTTPS 还是通过了 HTTP 来传输信息，但是信息通过 TLS 协议进行了加密。 TLS 协议位于传输层之上，应用层之下。首次进行 TLS 协议传输需要两个 RTT ，接下来可以通过 Session Resumption 减少到一个 RTT。 在 TLS 中使用了两种加密技术，分别为：对称加密和非对称加密。 对称加密 对称加密就是两边拥有相同的秘钥，两边都知道如何将密文加密解密。 这种加密方式固然很好，但是问题就在于如何让双方知道秘钥。因为传输数据都是走的网络，如果将秘钥通过网络的方式传递的话，一旦秘钥被截获就没有加密的意义的。 非对称加密 有公钥私钥之分，公钥所有人都可以知道，可以将数据用公钥加密，但是将数据解密必须使用私钥解密，私钥只有分发公钥的一方才知道。 这种加密方式就可以完美解决对称加密存在的问题。假设现在两端需要使用对称加密，那么在这之前，可以先使用非对称加密交换秘钥。 简单流程如下：首先服务端将公钥公布出去，那么客户端也就知道公钥了。接下来客户端创建一个秘钥，然后通过公钥加密并发送给服务端，服务端接收到密文以后通过私钥解密出正确的秘钥，这时候两端就都知道秘钥是什么了。 数字证书（digital certificate） 在非对称加密通信过程中，服务器需要将公钥发送给客户端，在这一过程中，公钥很可能会被第三方拦截并替换，然后这个第三方就可以冒充服务器与客户端进行通信，这就是传说中的“中间人攻击”（man in the middle attack）。解决此问题的方法是通过受信任的第三方交换公钥，具体做法就是服务器不直接向客户端发送公钥，而是要求受信任的第三方，也就是证书认证机构（Certificate Authority, 简称 CA）将公钥合并到数字证书中，然后服务器会把公钥连同证书一起发送给客户端，私钥则由服务器自己保存以确保安全。数字证书一般包含以下内容： 证书所有者的公钥 证书所有者的专有名称 证书颁发机构的专有名称 证书的有效起始日期 证书的过期日期 证书数据格式的版本号 序列号，这是证书颁发机构为该证书分配的唯一标识符 数字签名 (digital signature) 这个概念很好理解，其实跟人的手写签名类似，是为了确保数据发送者的合法身份，也可以确保数据内容未遭到篡改，保证数据完整性。与手写签名不同的是，数字签名会随着文本数据的变化而变化。具体到数字证书的应用场景，数字签名的生成和验证流程如下： 服务器对证书内容进行信息摘要计算 (常用算法有 SHA-256等)，得到摘要信息，再用私钥把摘要信息加密，就得到了数字签名 服务器把数字证书连同数字签名一起发送给客户端 客户端用公钥解密数字签名，得到摘要信息 客户端用相同的信息摘要算法重新计算证书摘要信息，然后对这两个摘要信息进行比对，如果相同，则说明证书未被篡改，否则证书验证失败 证书链 (certificate chain) 证书链，也称为证书路径，是用于认证实体合法身份的证书列表，具体到 HTTPS 通信中，就是为了验证服务器的合法身份。之所以使用证书链，是为了保证根证书 (root CA certificate)的安全，中间层可以看做根证书的代理，起到了缓冲的作用。 证书链从根证书开始，并且证书链中的每一级证书所标识的实体都要为其下一级证书签名，而根证书自身则由证书颁发机构签名。客户端在验证证书链时，必须对链中所有证书的数字签名进行验证，直到达到根证书为止。 密码规范和密码组合 (CipherSpecs 和 CipherSuites) 通信双方在安全连接中所使用的算法必须符合密码安全协议的规定，CipherSpecs 和 CipherSuites 正好定义了合法的密码算法组合。CipherSpecs 用于认证加密算法和信息摘要算法的组合，通信双方必须同意这个密码规范才能进行通信。而 CipherSuites 则定义了 SSL / TLS 安全连接中所使用的加密算法的组合，该组合包含三种不同的算法： 握手期间所使用的的密钥交换和认证算法 (最常用的是 RSA 算法) 加密算法 (用于握手完成后的对称加密，常用的有 AES、3DES等) 信息摘要算法 (常用的有 SHA-256、SHA-1 和 MD5 等) TLS 握手 TLS 握手的目的是建立安全连接，那么通信双方在这个过程中究竟干了什么呢？下面就是答案： 商定双方通信所使用的的 TLS 版本 (例如 TLS1.0, 1.2, 1.3等等)； 确定双方所要使用的密码组合； 客户端通过服务器的公钥和数字证书上的数字签名验证服务端的身份； 生成会话密钥，该密钥将用于握手结束后的对称加密。 TLS 握手详细过程 \"client hello\" 消息：客户端通过发送 \"client hello\" 消息向服务器发起握手请求，该消息包含了客户端所支持的 TLS 版本和密码组合以供服务器进行选择，还有一个 \"client random\" 随机字符串。 \"server hello\" 消息：服务器发送 \"server hello\" 消息对客户端进行回应，该消息包含了数字证书，服务器选择的密码组合和 \"server random\" 随机字符串。 验证：客户端对服务器发来的证书进行验证，确保对方的合法身份，验证过程可以细化为以下几个步骤： 检查数字签名 验证证书链 检查证书的有效期 检查证书的撤回状态 (撤回代表证书已失效) \"premaster secret\" 字符串：客户端向服务器发送另一个随机字符串 \"premaster secret (预主密钥)\"，这个字符串是经过服务器的公钥加密过的，只有对应的私钥才能解密。 使用私钥：服务器使用私钥解密 \"premaster secret\"。 生成共享密钥：客户端和服务器均使用 client random，server random 和 premaster secret，并通过相同的算法生成相同的共享密钥 KEY。 客户端就绪：客户端发送经过共享密钥 KEY 加密过的 \"finished\" 信号。 服务器就绪：服务器发送经过共享密钥 KEY 加密过的 \"finished\" 信号。 达成安全通信：握手完成，双方使用对称加密进行安全通信。 HTTP 和 HTTPS 的区别 HTTPS 是 HTTP 协议的安全版本，HTTP 协议的数据传输是明文的，是不安全的，HTTPS 使用了 SSL/TLS 协议进行了加密处理。 HTTP 和 HTTPS 使用连接方式不同，默认端口也不一样，HTTP 是 80 端口，HTTPS 是443 端口。 HTTPS 协议需要先进行 TLS 握手，导致页面的加载时间延长近 50%； HTTPS 连接缓存不如 HTTP 高效，会增加数据开销和功耗； HTTPS 申请证书需要钱，功能越强大的证书费用越高。 TLS 涉及到的安全算法会消耗 CPU 资源，对服务器资源消耗较大。 Copyright © TeamSecret 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-10-25 12:50:06 "},"net/http2/":{"url":"net/http2/","title":"HTTP2","keywords":"","body":"HTTP/2 和 HTTP/3 HTTP/2 很好的解决了当下最常用的 HTTP/1 所存在的一些性能问题，只需要升级到该协议就可以减少很多之前需要做的性能优化工作，当然兼容问题以及如何优雅降级应该是国内还不普遍使用的原因之一。 虽然 HTTP/2 已经解决了很多问题，但是并不代表它已经是完美的了，HTTP/3 就是为了解决 HTTP/2 所存在的一些问题而被推出来的。 HTTP/2 在 HTTP/1 中，为了性能考虑，我们会引入雪碧图、将小图内联、使用多个域名等等的方式。这一切都是因为浏览器限制了同一个域名下的请求数量（Chrome 下一般是限制六个连接），当页面中需要请求很多资源的时候，队头阻塞（Head of line blocking）会导致在达到最大请求数量时，剩余的资源需要等待其他资源请求完成后才能发起请求。 在 HTTP/2 中引入了多路复用的技术，这个技术可以只通过一个 TCP 连接就可以传输所有的请求数据。多路复用很好的解决了浏览器限制同一个域名下的请求数量的问题，同时也间接更容易实现全速传输，毕竟新开一个 TCP 连接都需要慢慢提升传输速度。 二进制传输 HTTP/2 中所有加强性能的核心点在于此。在之前的 HTTP 版本中，我们是通过文本的方式传输数据。在 HTTP/2 中引入了新的编码机制，所有传输的数据都会被分割，并采用二进制格式编码。 多路复用 在 HTTP/2 中，有两个非常重要的概念，分别是帧（frame）和流（stream）。 帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。 多路复用，就是在一个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。 Header 压缩 在 HTTP/1 中，我们使用文本的形式传输 header，在 header 携带 cookie 的情况下，可能每次都需要重复传输几百到几千的字节。 在 HTTP /2 中，使用了 HPACK 压缩格式对传输的 header 进行编码，减少了 header 的大小。并在两端维护了索引表，用于记录出现过的 header ，后面在传输过程中就可以传输已经记录过的 header 的键名，对端收到数据后就可以通过键名找到对应的值。 服务端 Push 在 HTTP/2 中，服务端可以在客户端某个请求后，主动推送其他资源。 可以想象以下情况，某些资源客户端是一定会请求的，这时就可以采取服务端 push 的技术，提前给客户端推送必要的资源，这样就可以相对减少一点延迟时间。当然在浏览器兼容的情况下你也可以使用 prefetch 。 HTTP/3 虽然 HTTP/2 解决了很多之前旧版本的问题，但是它还是存在一个巨大的问题，虽然这个问题并不是它本身造成的，而是底层支撑的 TCP 协议的问题。 因为 HTTP/2 使用了多路复用，一般来说同一域名下只需要使用一个 TCP 连接。当这个连接中出现了丢包的情况，那就会导致 HTTP/2 的表现情况反倒不如 HTTP/1 了。 因为在出现丢包的情况下，整个 TCP 都要开始等待重传，也就导致了后面的所有数据都被阻塞了。但是对于 HTTP/1 来说，可以开启多个 TCP 连接，出现这种情况反到只会影响其中一个连接，剩余的 TCP 连接还可以正常传输数据。 那么可能就会有人考虑到去修改 TCP 协议，其实这已经是一件不可能完成的任务了。因为 TCP 存在的时间实在太长，已经充斥在各种设备中，并且这个协议是由操作系统实现的，更新起来不大现实。 基于这个原因，Google 就更起炉灶搞了一个基于 UDP 协议的 QUIC 协议，并且使用在了 HTTP/3 上，当然 HTTP/3 之前名为 HTTP-over-QUIC，从这个名字中我们也可以发现，HTTP/3 最大的改造就是使用了 QUIC，接下来我们就来学习关于这个协议的内容。 QUIC 之前我们学习过 UDP 协议的内容，知道这个协议虽然效率很高，但是并不是那么的可靠。QUIC 虽然基于 UDP，但是在原本的基础上新增了很多功能，比如多路复用、0-RTT、使用 TLS1.3 加密、流量控制、有序交付、重传等等功能。这里我们就挑选几个重要的功能学习下这个协议的内容。 QUIC 的多路复用 虽然 HTTP/2 支持了多路复用，但是 TCP 协议终究是没有这个功能的。QUIC 原生就实现了这个功能，并且传输的单个数据流可以保证有序交付且不会影响其他的数据流，这样的技术就解决了之前 TCP 存在的问题。 并且 QUIC 在移动端的表现也会比 TCP 好。因为 TCP 是基于 IP 和端口去识别连接的，这种方式在多变的移动端网络环境下是很脆弱的。但是 QUIC 是通过 ID 的方式去识别一个连接，不管你网络环境如何变化，只要 ID 不变，就能迅速重连上。 0-RTT 通过使用类似 TCP 快速打开的技术，缓存当前会话的上下文，在下次恢复会话的时候，只需要将之前的缓存传递给服务端验证通过就可以进行传输了。 纠错机制 假如说这次我要发送三个包，那么协议会算出这三个包的异或值并单独发出一个校验包，也就是总共发出了四个包。 当出现其中的非校验包丢包的情况时，可以通过另外三个包计算出丢失的数据包的内容。 当然这种技术只能使用在丢失一个包的情况下，如果出现丢失多个包就不能使用纠错机制了，只能使用重传的方式了。 Copyright © TeamSecret 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-10-22 11:33:23 "},"interview/":{"url":"interview/","title":"面试问题集合","keywords":"","body":"面试 CSS 相关问题 flex 有哪些常用的属性？flex:1; 的含义是什么？ 移动端适配 JS 问题 原型链 闭包 JSON.parse(JSON.stringify(data)) 的缺陷 Proxy 和 Reflect JS 异步实现 事件循环【浏览器中的事件循环，面试必问】（点击事件属于微任务还是宏任务？） 防抖节流作用与原理，手写防抖节流函数 TS 问题 什么是元组？ 什么是修饰器？ 什么是泛型？ Interface 和 & 有什么区别？ WebPack 问题 webpack 的 loader 和 plugin 有什么区别？【高频考点】 babel 是什么，原理了解吗 Vue 问题 Vue 组件通信方式【高频考点】 如何修改 vue-computed 的值？ vue 自定义指令（生命周期 传参方式）【高频考点】 vue template 的几种写法 vue 修饰符 组件封装的要点 如何扩展组件功能？ 什么是作用域插槽？【高频考点】 vue 异步组件与动态组件 vue 如何实现列表过渡动画 在 Vue 中使用 JSX 前端技术选型的思考点？在什么情况下你会考虑使用 React 搭建项目？ Computed 和 Watch 的区别 实现 Computed vue 路由原理 vue 插件 vue 响应式原理，为什么 vue2 不用 proxy，为什么 vue3 要用 proxy？ 函数式组件与普通组件 网络 浏览器缓存策略【高频考点】 强缓存和协商缓存【高频考点】 304状态码 http2【高频考点】 如何设计一套符合 RESTful 标准的 API？ 浏览器相关知识 重绘与回流，什么时候会导致回流？ 跨域（简单请求和复杂请求[哪些情况会产生复杂请求]）【高频考点】 浏览器多个页签之间如何通信？ webworker, SharedWorker 和 ServiceWorker 的区别？ 事件冒泡和事件捕获 前端存储方式有哪几种？indexdb 的应用场景？ 前端安全问题（CSRF，XSS，iframe安全[X-FRAME-OPTIONS]）【高频考点】 前端性能优化【必考】 cdn 原理和优势 CSS 相关问题 flex 有哪些常用的属性？flex:1; 的含义是什么？ 开启 flex 布局：display: flex; 父容器上设置主轴的方向：flex-direction 设置子容器沿主轴排列：justify-content 设置子容器如何沿交叉轴排列：align-items 设置换行方式：flex-wrap 轴向与换行组合设置：flex-flow 多行沿交叉轴对齐：align-content 子容器在主轴上如何伸缩：flex 单独设置子容器如何沿交叉轴排列：align-self 设置基准大小：flex-basis 设置扩展比例：flex-grow 设置收缩比例：flex-shrink 设置排列顺序：order 查看 MDN 文档 flex: initial 是把 flex 元素重置为 Flexbox 的初始值，它相当于 flex: 0 1 auto。在这里 flex-grow 的值为 0，所以 flex 元素不会超过它们 flex-basis 的尺寸。flex-shrink 的值为 1, 所以可以缩小 flex 元素来防止它们溢出。flex-basis 的值为 auto。 Flex 元素尺寸可以是在主维度上设置的，也可以是根据内容自动得到的。 flex: auto 等同于 flex: 1 1 auto；和上面的 flex:initial 基本相同，但是这种情况下，flex 元素在需要的时候既可以拉伸也可以收缩。 flex: none 可以把 flex 元素设置为不可伸缩。它和设置为 flex: 0 0 auto 是一样的。元素既不能拉伸或者收缩，但是元素会按具有 flex-basis: auto 属性的 flexbox 进行布局。 flex: 1 相当于 flex: 1 1 0。元素可以在 flex-basis 为 0 的基础上伸缩。 移动端适配 flex 布局 + px 基于设计稿使用 flex 做布局后也能在其他设备上合理展示。 手机屏幕的逻辑像素一般在 320px～428px 这个范围，手机页面最常见的布局就是水平均分排列和两栏布局(如下图所示)。使用 flex 布局实现的水平均分排列原本就是响应式的，不管是 320 还是 428 的屏幕都是均分排列。对于两栏布局，固定部分的宽度相同，自适应部分随着屏幕尺寸的差异也会自动展示更多或者更少的内容。 这种布局方式的缺陷在于：页面中的元素实体（如文字）会出现小屏幕中太大，大屏幕中太小的问题，需要手动媒体查询微调。 等比缩放 所谓的等比缩放，就是设计师基于一个尺寸做一套设计图，开发工程师会基于设计图 100% 还原页面。在不同屏幕上的视觉呈现比例完全一致。 优点： 简单、可控，可以一套代码满足任何场景 缺点： 手机屏幕之所以越来越大，本意是想展示更多的内容，而不是让文字图片越变越大。反过来看，如果文字图片在 IPhone12 Max Pro 上看起来展示合理，在 IPhone 6s 上会小的像蚂蚁。 等比缩放适配的具体方案： viewport 缩放方案：利用 JS 动态计算 viewport 的值，此方法为整体缩放，不能局部控制 动态 rem 方案：利用 JS 动态计算根字体大小 vw 适配方案：对于需要缩放的元素，使用 vw 单位 JS 问题 原型链 原型链 闭包 闭包 JSON.parse(JSON.stringify(data)) 的缺陷 JSON.parse(JSON.stringify(data)) Proxy 和 Reflect Proxy 和 Reflect JS 异步实现 JS 异步编程 事件循环【浏览器中的事件循环，面试必问】（点击事件属于微任务还是宏任务？） 事件循环 点击事件应当属于同步（sync）执行的代码，和 script 标签一样自上而下执行，并不会加入到 macrotask 队列当中。 // 以下代码会依次输出： start -> click -> promise console.log('start'); new Promise((resolve, reject) => { resolve(1) }).then(() => { console.log('promise'); }) document.getElementById('div').addEventListener('click', () => { console.log('click'); }) document.getElementById('div').click() 如果将上述代码的点击事件换成 setTimeout： // 以下代码会依次输出： start -> promise -> click console.log('start'); new Promise((resolve, reject) => { resolve(1) }).then(() => { console.log('promise'); }) setTimeout(() => { console.log('click') }, 0); 防抖节流作用与原理，手写防抖节流函数 防抖节流 TypeScript 什么是元组？ TypeScript 中，数组中的元素一般只能是由相同数据类型组成（any[] 除外），如果我们想要存储不同类型的元素，则可以使用元组。 TypeScript 中的元组（Tuple）从外形上来看和数组相差不多， 但是元组中允许存储不同类型的元素，数组中的元素必须是相同的类型。 例如声明一个由数字类型、字符串类型、布尔类型构成的元素： let tup1:[number, string, boolean] = [1, 'a', true]; console.log(tup1); 什么是修饰器？ 装饰器是一种特殊类型的声明，它能够被附加到类声明，方法， 访问符，属性或参数上。 装饰器使用 @expression 这种形式，expression 求值后必须为一个函数，它会在运行时被调用，被装饰的声明信息做为参数传入。详细文档 什么是泛型？ 泛型，允许我们在定义的时候不具体指定类型，而是泛泛地说一种类型，并在函数调用的时候再指定具体的参数类型。比如当我们想要使返回值的类型与传入参数的类型是相同的时候，就可以使用泛型： function identity(arg: T): T { return arg; } Interface 和 & 有什么区别？ & 表示交叉类型，是将多个类型合并为一个类型，它包含了所需的所有类型的特性。 Interface 用于对「对象的形状（Shape）」进行描述。 WebPack webpack 的 loader 和 plugin 有什么区别？【高频考点】 loader loader 是文件加载器，能够加载资源文件，并对这些文件进行一些处理，诸如编译、压缩等，最终一起打包到指定的文件中。 处理一个文件可以使用多个 loader，loader 的加载顺序和配置顺序是相反的 第一个执行的 loader 接收源文件的内容作为参数，下一个 loader 接收前一个 loader 的返回值作为参数，最后一个 loader 会返回此模块的 javaScript 的源码 plugin 在 webpack 运行的生命周期中会广播很多的事件（ hooks中的事件监听 ），plugin 可以监听这些事件（在 apply 方法中监听 hooks 的声明周期），在合适的时机通过 webpack 提供的 Api 改变输出结果。 loader 和 plugin 的区别 对于 loader 来说，它是一个转换器，把 A 文件编译转换成 B 文件，这里只做单纯的文件转换的工作 plugin 是一个扩展器，它丰富了 webpack 本身，在 webpack 的打包过程中，它并不直接操作文件，而是订阅 webpack 的声命周期，执行更广泛的操作。 babel 是什么，原理了解吗 Babel 是一个 JavaScript 编译器。他把最新版的 javascript 编译成当下可以执行的版本，简言之，利用 babel 就可以让我们在当前的项目中随意的使用这些新最新的 es6，甚至 es7 的语法。 Babel 的三个主要处理步骤分别是： 解析（parse），转换（transform），生成（generate）。 解析 将代码解析成抽象语法树（AST），每个 js 引擎（比如 Chrome 浏览器中的 V8 引擎）都有自己的 AST 解析器，而 Babel 是通过 Babylon 实现的。在解析过程中有两个阶段：词法分析和语法分析，词法分析阶段把字符串形式的代码转换为令牌（tokens）流，令牌类似于 AST 中节点；而语法分析阶段则会把一个令牌流转换成 AST 的形式，同时这个阶段会把令牌中的信息转换成 AST 的表述结构。 转换 在这个阶段，Babel 接受得到 AST 并通过 babel-traverse 对其进行深度优先遍历，在此过程中对节点进行添加、更新及移除操作。这部分也是 Babel 插件介入工作的部分。 生成 将经过转换的 AST 通过 babel-generator 再转换成 js 代码，过程就是深度优先遍历整个 AST，然后构建可以表示转换后代码的字符串。 Vue Vue 组件通信方式【高频考点】 Vue 组件通信方式 如何修改 vue-computed 的值？ 我们知道 computed 动态计算属性默认只有 get 方法： computed: { test () { return this.a + this.b } } 如果我们直接修改 test 的值，就会报错： this.test = 123 // [Vue warn]: Computed property \"test\" was assigned to but it has no setter. 可以通过给 computed 手动添加一个 setter 方法，并在方法中修改另一个参数值，来达到修改 computed 的目的： data () { return { a: 1, b: 2 } }, computed: { c: { get () { return this.a + this.b }, set (val) { this.a = val } } }, mounted () { // 运行这段代码后，a = 123, b = 2, c = 125 this.c = 123 } vue 自定义指令（生命周期 传参方式）【高频考点】 指令本质上是装饰器，是 vue 对 HTML 元素的扩展，给 HTML 元素增加自定义功能。vue 编译 DOM 时，会找到指令对象，执行指令的相关方法。 自定义指令有五个生命周期（也叫钩子函数），分别是 bind、inserted、update、componentUpdated、unbind。 bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。 inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。 update：被绑定于元素所在的模板更新时调用，而无论绑定值是否变化。通过比较更新前后的绑定值，可以忽略不必要的模板更新。 componentUpdated：被绑定元素所在模板完成一次更新周期时调用。 unbind：只调用一次，指令与元素解绑时调用。 钩子函数的接收的参数中有一个 binding 对象，这里面包含以下 property： name：指令名，不包括 v- 前缀。 value：指令的绑定值，例如：v-my-directive=\"1 + 1\" 中，绑定值为 2。 oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。 expression：字符串形式的指令表达式。例如 v-my-directive=\"1 + 1\" 中，表达式为 \"1 + 1\"。 arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 \"foo\"。 modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。 原理 在生成 ast 语法树时，遇到指令会给当前元素添加 directives 属性 通过 genDirectives 生成指令代码 在 patch 前将指令的钩子提取到 cbs 中,在 patch 过程中调用对应的钩子 当执行指令对应钩子函数时，调用对应指令定义的方法 vue template 的几种写法 字符串模板 Vue.component('my-checkbox', { template: ` {{title}} `, data() { return { checked: false, title: 'Check me' } }, methods: { check() { this.checked = !this.checked; } } }); x-template 使用此方法，模板被定义在例如 index.html 文件中的 script 标签里。此 script 标签使用 text/x-template 标记，并由组件定义的 id 引用。 Vue.component('my-checkbox', { template: '#checkbox-template', data() { return { checked: false, title: 'Check me' } }, methods: { check() { this.checked = !this.checked; } } }); 内联模板 通过在组件中添加 inline-template 属性，你可以向 Vue 指示内部内容是其模板，而不是将其视为分布式内容（参考 slot） 。 它与 x-templates 具有相同的缺点，不过一个优点是，内容在 HTML 模板的正确位置，因此可以在页面加载时呈现，而不是等到 JavaScript 运行。 Vue.component('my-checkbox', { data() { return { checked: false, title: 'Check me' } }, methods: { check() { this.checked = !this.checked; } } }); render 函数 Vue.component('my-checkbox', { data () { return { checked: false, title: 'Check me' } }, methods: { check () { this.checked = !this.checked; } }, render (createElement) { return createElement( 'div', { attrs: { 'class': 'checkbox-wrapper' }, on: { click: this.check } }, [ createElement( 'div', { 'class': { checkbox: true, checked: this.checked } } ), createElement( 'div', { attrs: { 'class': 'title' } }, [ this.title ] ) ] ); } }); JSX Vue.component('my-checkbox', { data() { return { checked: false, title: 'Check me' } }, methods: { check() { this.checked = !this.checked; } }, render() { return { this.title } } }); 单文件组件 export default { data() { return { checked: false, title: 'Check me' } }, methods: { check() { this.checked = !this.checked; } } } vue 修饰符 在事件处理程序中调用 event.preventDefault() 或 event.stopPropagation() 是非常常见的需求。尽管我们可以在方法中轻松实现这点，但更好的方式是：方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。 为了解决这个问题，Vue.js 为 v-on 提供了事件修饰符。修饰符是由点开头的指令后缀来表示的。 .stop .prevent .capture .self .once .passive 官方文档 组件封装的要点 可以从组件拆分原则，组件通信，事件处理，样式隔离，插槽（具名插槽，不具名插槽，作用域插槽）等方面回答。 如何扩展组件功能？ Mixin 和 extends Mixin extends 什么是作用域插槽？【高频考点】 简单理解，就是把子组件中需要的数据，定义到父组件当中，通过 scope 进行传递。 作用域插槽 vue 异步组件与动态组件 动态组件 & 异步组件 vue 如何实现列表过渡动画 可以使用 Vue 提供的 transition 组件 获取元素坐标，JS 修改 transform 值（window.requestAnimationFrame 方法的使用） 在 Vue 中使用 JSX 结合函数式组件回答 官方文档 前端技术选型的思考点？在什么情况下你会考虑使用 React 搭建项目？ 这个问题就见仁见智了，框架本身差别不大，个人感觉还是看团队偏好和技术实力。 Computed 和 Watch 的区别 computed：用于处理复杂的逻辑运算；一个数据受一个或多个数据影响；用来处理 watch 和 methods 无法处理的，或处理起来不方便的情况。例如处理模板中的复杂表达式、购物车里面的商品数量和总金额之间的变化关系等。 watch：用来处理当一个属性发生变化时，需要执行某些具体的业务逻辑操作，或要在数据变化时执行异步或开销较大的操作；一个数据改变影响多个数据。例如用来监控路由、input 输入框值的特殊处理等。 官方文档 实现 Computed 简单总结：在 initComputed 的时候，会将 computed 对象中的每一个 key 创建一个 watcher，watcher 的 getter 就是你写的函数，当依赖变化的时候，这个 watcher 会将自己的 lazy 属性设置为 true。 并不计算自己的值，然后将 computed 的 key 通过设置 defineProperty getter setter 设置到 vm 上，（defineComputed 方法）， 同时，让组件的渲染 watcher 也收集依赖，当依赖变化的时候，触发渲染 watcher 的更新方法， 会判断 computed watcher 是否为 dirty，如果为 dirty，那么计算，拿到值，然后 dirty 设为 false，否则直接拿值。 vue 路由原理 前端路由 vue 插件 开发插件：暴露一个 install 方法。这个方法的第一个参数是 Vue 构造器，第二个参数是一个可选的选项对象。 使用插件：通过全局方法 Vue.use() 使用插件。可以提到 Vue.use() 使用的单例模式。 官方文档 vue 响应式原理，为什么 vue2 不用 proxy，为什么 vue3 要用 proxy？ 响应式原理 Proxy 的优势 函数式组件与普通组件 什么是函数式组件？函数式组件，我们可以理解为没有内部状态，没有生命周期钩子函数，没有 this （不需要实例化）的组件。 在日常写 bug 的过程中，经常会开发一些纯展示性的业务组件，比如一些详情页面，列表界面等，它们有一个共同的特点是只需要将外部传入的数据进行展现，不需要有内部状态，不需要在生命周期钩子函数里面做处理，这时候你就可以考虑使用函数式组件。 export default { // 通过配置 functional 属性指定组件为函数式组件 functional: true, // 组件接收的外部属性 props: { avatar: { type: String } }, /** * 渲染函数 * @param {*} h * @param {*} context 函数式组件没有this, props, slots等都在context上面挂着 */ render(h, context) { const { props } = context if (props.avatar) { return } return } } 为什么使用函数式组件 最主要最关键的原因是函数式组件不需要实例化，无状态，没有生命周期，所以渲染性能要好于普通组件 函数式组件结构比较简单，代码结构更清晰 函数式组件与普通组件的区别 函数式组件需要在声明组件是指定 functional 函数式组件不需要实例化，所以没有 this, this 通过 render 函数的第二个参数来代替 函数式组件没有生命周期钩子函数，不能使用计算属性，watch 等等 函数式组件不能通过 $emit 对外暴露事件，调用事件只能通过 context.listeners.click 的方式调用外部传入的事件 因为函数式组件是没有实例化的，所以在外部通过 ref 去引用组件时，实际引用的是 HTMLElement 函数式组件的 props 可以不用显示声明，所以没有在 props 里面声明的属性都会被自动隐式解析为 prop ,而普通组件所有未声明的属性都被解析到 $attrs 里面，并自动挂载到组件根元素上面(可以通过 inheritAttrs 属性禁止) 网络 浏览器缓存策略【高频考点】 浏览器缓存策略 强缓存和协商缓存【高频考点】 缓存策略 304状态码 结合协商缓存内容：当浏览器发起请求验证资源时，如果资源没有改变，那么服务端就会返回 304 状态码，并且更新浏览器缓存有效期。 http2【高频考点】 http/2 如何设计一套符合 RESTful 标准的 API？ 主要考虑几个方面： 协议 API 与用户的通信协议，总是使用 HTTPS 协议。 域名 应该尽量将 API 部署在专用域名之下。 https://api.example.com 如果确定 API 很简单，不会有进一步扩展，可以考虑放在主域名下。 https://example.org/api/ 版本 应该将 API 的版本号放入 URL。 https://api.example.com/v1/ 另一种做法是，将版本号放在HTTP头信息中，但不如放入URL方便和直观。 路径 路径又称\"终点\"（endpoint），表示API的具体网址。 在 RESTful 架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的\"集合\"（collection），所以API中的名词也应该使用复数。 举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样。 https://api.example.com/v1/zoos https://api.example.com/v1/animals https://api.example.com/v1/employees HTTP 动词 对于资源的具体操作类型，由 HTTP 动词表示。例如： GET /zoos：列出所有动物园 POST /zoos：新建一个动物园 GET /zoos/ID：获取某个指定动物园的信息 PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息） PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息） DELETE /zoos/ID：删除某个动物园 GET /zoos/ID/animals：列出某个指定动物园的所有动物 DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物 过滤信息 如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。 ?limit=10：指定返回记录的数量 ?offset=10：指定返回记录的开始位置。 ?page=2&per_page=100：指定第几页，以及每页的记录数。 ?sortby=name&order=asc：指定返回结果按照哪个属性排序，以及排序顺序。 ?animal_type_id=1：指定筛选条件 参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，GET /zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。 状态码 服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。 200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。 201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。 202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务） 204 NO CONTENT - [DELETE]：用户删除数据成功。 400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。 401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。 403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。 404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。 406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。 410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。 422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。 500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。 错误处理 如果状态码是 4xx，就应该向用户返回出错信息。一般来说，返回的信息中将 error 作为键名，出错信息作为键值即可。 { error: \"Invalid API key\" } 返回结果 针对不同操作，服务器向用户返回的结果应该符合以下规范。 GET /collection：返回资源对象的列表（数组） GET /collection/resource：返回单个资源对象 POST /collection：返回新生成的资源对象 PUT /collection/resource：返回完整的资源对象 PATCH /collection/resource：返回完整的资源对象 DELETE /collection/resource：返回一个空文档 Hypermedia API RESTful API 最好做到 Hypermedia，即返回结果中提供链接，连向其他 API 方法，使得用户不查文档，也知道下一步应该做什么。 比如，当用户向 api.example.com 的根目录发出请求，会得到这样一个文档。 { \"link\": { \"rel\": \"collection https://www.example.com/zoos\", \"href\": \"https://api.example.com/zoos\", \"title\": \"List of zoos\", \"type\": \"application/vnd.yourformat+json\" } } 上面代码表示，文档中有一个 link 属性，用户读取这个属性就知道下一步该调用什么 API 了。rel 表示这个 API 与当前网址的关系（collection 关系，并给出该 collection 的网址），href 表示 API 的路径，title 表示 API 的标题，type 表示返回类型。 Hypermedia API 的设计被称为 HATEOAS。Github 的 API 就是这种设计，访问 api.github.com 会得到一个所有可用 API 的网址列表。 { \"current_user_url\": \"https://api.github.com/user\", \"authorizations_url\": \"https://api.github.com/authorizations\", // ... } 从上面可以看到，如果想获取当前用户的信息，应该去访问 api.github.com/user，然后就得到了下面结果。 { \"message\": \"Requires authentication\", \"documentation_url\": \"https://developer.github.com/v3\" } 上面代码表示，服务器给出了提示信息，以及文档的网址。 其他 API的身份认证应该使用 OAuth 2.0 框架。 服务器返回的数据格式，应该尽量使用 JSON，避免使用 XML。 浏览器相关知识 重绘与回流，什么时候会导致回流？ 重绘与回流 跨域（简单请求和复杂请求[哪些情况会产生复杂请求]）【高频考点】 主要考察点还是 CORS（跨域资源共享） 跨域 浏览器多个页签之间如何通信？ 浏览器在设置 localstorage（sessionstorage 是会话级的存储空间，每个标签页都是单独的） 的时候会触发非当前页签的 storage 事件，通过监听这个事件就可以实现跨页签通信。 window.onstorage = (e) => {console.log(e)} // 或者 window.addEventListener('storage', (e) => console.log(e)) SharedWorker SharedWorker 可以被多个 window 共同使用，但必须保证这些标签页都是同源的（相同的协议，主机和端口号） 创建 SharedWorker 实例后，通过 postMessage 方法和监听 message 事件，实现跨标签页通信。 webworker, SharedWorker 和 ServiceWorker 的区别？ 简单来讲： webworker，执行一些耗时的阻塞线程影响浏览器渲染的 JS 代码 SharedWorker，多个 window、iframe 共用 ServiceWorker，可以用来做持续性缓存 事件冒泡和事件捕获 事件机制 前端存储方式有哪几种？indexdb 的应用场景？ 前端存储 indexdb 的应用场景：考虑数据量大小，数据复杂度，离线应用等场景。 前端安全问题（CSRF，XSS，iframe安全[X-FRAME-OPTIONS]）【高频考点】 前端安全问题 前端性能优化【必考】 前端性能优化 cdn 原理和优势 前端性能优化 内容分发网络（CDN）是一组分布在多个不同地理位置的 Web 服务器。我们都知道，当服务器离用户越远时，延迟越高。CDN 就是为了解决这一问题，在多个位置部署服务器，让用户离服务器更近，从而缩短请求时间。 另外，可以结合 CDN 和 HTTP2 协议的多路复用，将话题引导至 HTTP 协议相关内容。 Copyright © TeamSecret 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-10-22 11:56:18 "}}